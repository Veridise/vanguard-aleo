program uniswap_v5.aleo;

record tokenA:
    owner as address.private;
    amount as u64.private;

record tokenB:
    owner as address.private;
    amount as u64.private;

struct Config:
    total_supply as u64;
    k_last as u64;
    lock as boolean;
    minimum_liquidity as u64;
    reserve_a as u64;
    reserve_b as u64;

record LiquidityPool:
    owner as address.private;
    amount as u64.private;

mapping account_a:
    key as address.public;
    value as u64.public;

mapping account_b:
    key as address.public;
    value as u64.public;

mapping config:
    key as field.public;
    value as Config.public;

mapping account:
    key as address.public;
    value as u64.public;

function mint_public_a:
    input r0 as address.public;
    input r1 as u64.public;
    cast aleo1y3yp6kaq4tl04u06fy4k43kvcl4azlddy0fsamdj6smsa6rnxg9sk09ltz into r2 as address;
    is.neq self.caller r2 into r3;
    lte r1 1000u64 into r4;
    not r3 into r5;
    or r5 r4 into r6;
    assert.eq r6 true ;
    async mint_public_a r0 r1 into r7;
    output r7 as uniswap_v5.aleo/mint_public_a.future;

finalize mint_public_a:
    input r0 as address.public;
    input r1 as u64.public;
    get.or_use account_a[r0] 0u64 into r2;
    add r2 r1 into r3;
    set r3 into account_a[r0];

function mint_private_a:
    input r0 as address.private;
    input r1 as u64.private;
    cast aleo1y3yp6kaq4tl04u06fy4k43kvcl4azlddy0fsamdj6smsa6rnxg9sk09ltz into r2 as address;
    is.neq self.caller r2 into r3;
    lte r1 1000u64 into r4;
    not r3 into r5;
    or r5 r4 into r6;
    assert.eq r6 true ;
    cast r0 r1 into r7 as tokenA.record;
    output r7 as tokenA.record;

function transfer_public_a:
    input r0 as address.public;
    input r1 as u64.public;
    async transfer_public_a self.caller r0 r1 into r2;
    output r2 as uniswap_v5.aleo/transfer_public_a.future;

finalize transfer_public_a:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as u64.public;
    get.or_use account_a[r0] 0u64 into r3;
    sub r3 r2 into r4;
    set r4 into account_a[r0];
    get.or_use account_a[r1] 0u64 into r5;
    add r5 r2 into r6;
    set r6 into account_a[r1];

function transfer_private_a:
    input r0 as tokenA.record;
    input r1 as address.private;
    input r2 as u64.private;
    sub r0.amount r2 into r3;
    cast r0.owner r3 into r4 as tokenA.record;
    cast r1 r2 into r5 as tokenA.record;
    output r4 as tokenA.record;
    output r5 as tokenA.record;

function transfer_private_to_public_a:
    input r0 as tokenA.record;
    input r1 as address.public;
    input r2 as u64.public;
    sub r0.amount r2 into r3;
    cast r0.owner r3 into r4 as tokenA.record;
    async transfer_private_to_public_a r1 r2 into r5;
    output r4 as tokenA.record;
    output r5 as uniswap_v5.aleo/transfer_private_to_public_a.future;

finalize transfer_private_to_public_a:
    input r0 as address.public;
    input r1 as u64.public;
    get.or_use account_a[r0] 0u64 into r2;
    add r2 r1 into r3;
    set r3 into account_a[r0];

function transfer_public_to_private_a:
    input r0 as address.public;
    input r1 as u64.public;
    cast r0 r1 into r2 as tokenA.record;
    async transfer_public_to_private_a self.caller r1 into r3;
    output r2 as tokenA.record;
    output r3 as uniswap_v5.aleo/transfer_public_to_private_a.future;

finalize transfer_public_to_private_a:
    input r0 as address.public;
    input r1 as u64.public;
    get.or_use account_a[r0] 0u64 into r2;
    sub r2 r1 into r3;
    set r3 into account_a[r0];

function mint_public_b:
    input r0 as address.public;
    input r1 as u64.public;
    cast aleo1y3yp6kaq4tl04u06fy4k43kvcl4azlddy0fsamdj6smsa6rnxg9sk09ltz into r2 as address;
    is.neq self.caller r2 into r3;
    lte r1 1000u64 into r4;
    not r3 into r5;
    or r5 r4 into r6;
    assert.eq r6 true ;
    async mint_public_b r0 r1 into r7;
    output r7 as uniswap_v5.aleo/mint_public_b.future;

finalize mint_public_b:
    input r0 as address.public;
    input r1 as u64.public;
    get.or_use account_b[r0] 0u64 into r2;
    add r2 r1 into r3;
    set r3 into account_b[r0];

function mint_private_b:
    input r0 as address.private;
    input r1 as u64.private;
    cast aleo1y3yp6kaq4tl04u06fy4k43kvcl4azlddy0fsamdj6smsa6rnxg9sk09ltz into r2 as address;
    is.neq self.caller r2 into r3;
    lte r1 1000u64 into r4;
    not r3 into r5;
    or r5 r4 into r6;
    assert.eq r6 true ;
    cast r0 r1 into r7 as tokenB.record;
    output r7 as tokenB.record;

function transfer_public_b:
    input r0 as address.public;
    input r1 as u64.public;
    async transfer_public_b self.caller r0 r1 into r2;
    output r2 as uniswap_v5.aleo/transfer_public_b.future;

finalize transfer_public_b:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as u64.public;
    get.or_use account_b[r0] 0u64 into r3;
    sub r3 r2 into r4;
    set r4 into account_b[r0];
    get.or_use account_b[r1] 0u64 into r5;
    add r5 r2 into r6;
    set r6 into account_b[r1];

function transfer_private_b:
    input r0 as tokenB.record;
    input r1 as address.private;
    input r2 as u64.private;
    sub r0.amount r2 into r3;
    cast r0.owner r3 into r4 as tokenB.record;
    cast r1 r2 into r5 as tokenB.record;
    output r4 as tokenB.record;
    output r5 as tokenB.record;

function transfer_private_to_public_b:
    input r0 as tokenB.record;
    input r1 as address.public;
    input r2 as u64.public;
    sub r0.amount r2 into r3;
    cast r0.owner r3 into r4 as tokenB.record;
    async transfer_private_to_public_b r1 r2 into r5;
    output r4 as tokenB.record;
    output r5 as uniswap_v5.aleo/transfer_private_to_public_b.future;

finalize transfer_private_to_public_b:
    input r0 as address.public;
    input r1 as u64.public;
    get.or_use account_b[r0] 0u64 into r2;
    add r2 r1 into r3;
    set r3 into account_b[r0];

function transfer_public_to_private_b:
    input r0 as address.public;
    input r1 as u64.public;
    cast r0 r1 into r2 as tokenB.record;
    async transfer_public_to_private_b self.caller r1 into r3;
    output r2 as tokenB.record;
    output r3 as uniswap_v5.aleo/transfer_public_to_private_b.future;

finalize transfer_public_to_private_b:
    input r0 as address.public;
    input r1 as u64.public;
    get.or_use account_b[r0] 0u64 into r2;
    sub r2 r1 into r3;
    set r3 into account_b[r0];

closure square_root:
    input r0 as u64;
    sub.w r0 0u64 into r1;
    div r1 2u64 into r2;
    add 0u64 r2 into r3;
    mul.w r3 r3 into r4;
    lte r4 r0 into r5;
    add r3 1u64 into r6;
    ternary r5 r6 0u64 into r7;
    sub r3 1u64 into r8;
    ternary r5 r0 r8 into r9;
    ternary r5 r3 0u64 into r10;
    lte 0u64 r0 into r11;
    ternary r11 r7 0u64 into r12;
    lte r12 r0 into r13;
    ternary r13 r9 r0 into r14;
    lte r12 r14 into r15;
    ternary r15 r10 0u64 into r16;
    sub.w r14 r12 into r17;
    div r17 2u64 into r18;
    add r12 r18 into r19;
    mul.w r19 r19 into r20;
    lte r20 r0 into r21;
    add r19 1u64 into r22;
    ternary r21 r22 r12 into r23;
    sub r19 1u64 into r24;
    ternary r21 r14 r24 into r25;
    ternary r21 r19 r16 into r26;
    lte r12 r14 into r27;
    ternary r27 r23 r12 into r28;
    lte r28 r14 into r29;
    ternary r29 r25 r14 into r30;
    lte r28 r30 into r31;
    ternary r31 r26 r16 into r32;
    sub.w r30 r28 into r33;
    div r33 2u64 into r34;
    add r28 r34 into r35;
    mul.w r35 r35 into r36;
    lte r36 r0 into r37;
    add r35 1u64 into r38;
    ternary r37 r38 r28 into r39;
    sub r35 1u64 into r40;
    ternary r37 r30 r40 into r41;
    ternary r37 r35 r32 into r42;
    lte r28 r30 into r43;
    ternary r43 r39 r28 into r44;
    lte r44 r30 into r45;
    ternary r45 r41 r30 into r46;
    lte r44 r46 into r47;
    ternary r47 r42 r32 into r48;
    sub.w r46 r44 into r49;
    div r49 2u64 into r50;
    add r44 r50 into r51;
    mul.w r51 r51 into r52;
    lte r52 r0 into r53;
    add r51 1u64 into r54;
    ternary r53 r54 r44 into r55;
    sub r51 1u64 into r56;
    ternary r53 r46 r56 into r57;
    ternary r53 r51 r48 into r58;
    lte r44 r46 into r59;
    ternary r59 r55 r44 into r60;
    lte r60 r46 into r61;
    ternary r61 r57 r46 into r62;
    lte r60 r62 into r63;
    ternary r63 r58 r48 into r64;
    sub.w r62 r60 into r65;
    div r65 2u64 into r66;
    add r60 r66 into r67;
    mul.w r67 r67 into r68;
    lte r68 r0 into r69;
    add r67 1u64 into r70;
    ternary r69 r70 r60 into r71;
    sub r67 1u64 into r72;
    ternary r69 r62 r72 into r73;
    ternary r69 r67 r64 into r74;
    lte r60 r62 into r75;
    ternary r75 r71 r60 into r76;
    lte r76 r62 into r77;
    ternary r77 r73 r62 into r78;
    lte r76 r78 into r79;
    ternary r79 r74 r64 into r80;
    sub.w r78 r76 into r81;
    div r81 2u64 into r82;
    add r76 r82 into r83;
    mul.w r83 r83 into r84;
    lte r84 r0 into r85;
    add r83 1u64 into r86;
    ternary r85 r86 r76 into r87;
    sub r83 1u64 into r88;
    ternary r85 r78 r88 into r89;
    ternary r85 r83 r80 into r90;
    lte r76 r78 into r91;
    ternary r91 r87 r76 into r92;
    lte r92 r78 into r93;
    ternary r93 r89 r78 into r94;
    lte r92 r94 into r95;
    ternary r95 r90 r80 into r96;
    sub.w r94 r92 into r97;
    div r97 2u64 into r98;
    add r92 r98 into r99;
    mul.w r99 r99 into r100;
    lte r100 r0 into r101;
    add r99 1u64 into r102;
    ternary r101 r102 r92 into r103;
    sub r99 1u64 into r104;
    ternary r101 r94 r104 into r105;
    ternary r101 r99 r96 into r106;
    lte r92 r94 into r107;
    ternary r107 r103 r92 into r108;
    lte r108 r94 into r109;
    ternary r109 r105 r94 into r110;
    lte r108 r110 into r111;
    ternary r111 r106 r96 into r112;
    sub.w r110 r108 into r113;
    div r113 2u64 into r114;
    add r108 r114 into r115;
    mul.w r115 r115 into r116;
    lte r116 r0 into r117;
    add r115 1u64 into r118;
    ternary r117 r118 r108 into r119;
    sub r115 1u64 into r120;
    ternary r117 r110 r120 into r121;
    ternary r117 r115 r112 into r122;
    lte r108 r110 into r123;
    ternary r123 r119 r108 into r124;
    lte r124 r110 into r125;
    ternary r125 r121 r110 into r126;
    lte r124 r126 into r127;
    ternary r127 r122 r112 into r128;
    sub.w r126 r124 into r129;
    div r129 2u64 into r130;
    add r124 r130 into r131;
    mul.w r131 r131 into r132;
    lte r132 r0 into r133;
    add r131 1u64 into r134;
    ternary r133 r134 r124 into r135;
    sub r131 1u64 into r136;
    ternary r133 r126 r136 into r137;
    ternary r133 r131 r128 into r138;
    lte r124 r126 into r139;
    ternary r139 r135 r124 into r140;
    lte r140 r126 into r141;
    ternary r141 r137 r126 into r142;
    lte r140 r142 into r143;
    ternary r143 r138 r128 into r144;
    sub.w r142 r140 into r145;
    div r145 2u64 into r146;
    add r140 r146 into r147;
    mul.w r147 r147 into r148;
    lte r148 r0 into r149;
    add r147 1u64 into r150;
    ternary r149 r150 r140 into r151;
    sub r147 1u64 into r152;
    ternary r149 r142 r152 into r153;
    ternary r149 r147 r144 into r154;
    lte r140 r142 into r155;
    ternary r155 r151 r140 into r156;
    lte r156 r142 into r157;
    ternary r157 r153 r142 into r158;
    lte r156 r158 into r159;
    ternary r159 r154 r144 into r160;
    sub.w r158 r156 into r161;
    div r161 2u64 into r162;
    add r156 r162 into r163;
    mul.w r163 r163 into r164;
    lte r164 r0 into r165;
    add r163 1u64 into r166;
    ternary r165 r166 r156 into r167;
    sub r163 1u64 into r168;
    ternary r165 r158 r168 into r169;
    ternary r165 r163 r160 into r170;
    lte r156 r158 into r171;
    ternary r171 r167 r156 into r172;
    lte r172 r158 into r173;
    ternary r173 r169 r158 into r174;
    lte r172 r174 into r175;
    ternary r175 r170 r160 into r176;
    sub.w r174 r172 into r177;
    div r177 2u64 into r178;
    add r172 r178 into r179;
    mul.w r179 r179 into r180;
    lte r180 r0 into r181;
    add r179 1u64 into r182;
    ternary r181 r182 r172 into r183;
    sub r179 1u64 into r184;
    ternary r181 r174 r184 into r185;
    ternary r181 r179 r176 into r186;
    lte r172 r174 into r187;
    ternary r187 r183 r172 into r188;
    lte r188 r174 into r189;
    ternary r189 r185 r174 into r190;
    lte r188 r190 into r191;
    ternary r191 r186 r176 into r192;
    sub.w r190 r188 into r193;
    div r193 2u64 into r194;
    add r188 r194 into r195;
    mul.w r195 r195 into r196;
    lte r196 r0 into r197;
    add r195 1u64 into r198;
    ternary r197 r198 r188 into r199;
    sub r195 1u64 into r200;
    ternary r197 r190 r200 into r201;
    ternary r197 r195 r192 into r202;
    lte r188 r190 into r203;
    ternary r203 r199 r188 into r204;
    lte r204 r190 into r205;
    ternary r205 r201 r190 into r206;
    lte r204 r206 into r207;
    ternary r207 r202 r192 into r208;
    sub.w r206 r204 into r209;
    div r209 2u64 into r210;
    add r204 r210 into r211;
    mul.w r211 r211 into r212;
    lte r212 r0 into r213;
    add r211 1u64 into r214;
    ternary r213 r214 r204 into r215;
    sub r211 1u64 into r216;
    ternary r213 r206 r216 into r217;
    ternary r213 r211 r208 into r218;
    lte r204 r206 into r219;
    ternary r219 r215 r204 into r220;
    lte r220 r206 into r221;
    ternary r221 r217 r206 into r222;
    lte r220 r222 into r223;
    ternary r223 r218 r208 into r224;
    sub.w r222 r220 into r225;
    div r225 2u64 into r226;
    add r220 r226 into r227;
    mul.w r227 r227 into r228;
    lte r228 r0 into r229;
    add r227 1u64 into r230;
    ternary r229 r230 r220 into r231;
    sub r227 1u64 into r232;
    ternary r229 r222 r232 into r233;
    ternary r229 r227 r224 into r234;
    lte r220 r222 into r235;
    ternary r235 r231 r220 into r236;
    lte r236 r222 into r237;
    ternary r237 r233 r222 into r238;
    lte r236 r238 into r239;
    ternary r239 r234 r224 into r240;
    sub.w r238 r236 into r241;
    div r241 2u64 into r242;
    add r236 r242 into r243;
    mul.w r243 r243 into r244;
    lte r244 r0 into r245;
    add r243 1u64 into r246;
    ternary r245 r246 r236 into r247;
    sub r243 1u64 into r248;
    ternary r245 r238 r248 into r249;
    ternary r245 r243 r240 into r250;
    lte r236 r238 into r251;
    ternary r251 r247 r236 into r252;
    lte r252 r238 into r253;
    ternary r253 r249 r238 into r254;
    lte r252 r254 into r255;
    ternary r255 r250 r240 into r256;
    sub.w r254 r252 into r257;
    div r257 2u64 into r258;
    add r252 r258 into r259;
    mul.w r259 r259 into r260;
    lte r260 r0 into r261;
    add r259 1u64 into r262;
    ternary r261 r262 r252 into r263;
    sub r259 1u64 into r264;
    ternary r261 r254 r264 into r265;
    ternary r261 r259 r256 into r266;
    lte r252 r254 into r267;
    ternary r267 r263 r252 into r268;
    lte r268 r254 into r269;
    ternary r269 r265 r254 into r270;
    lte r268 r270 into r271;
    ternary r271 r266 r256 into r272;
    sub.w r270 r268 into r273;
    div r273 2u64 into r274;
    add r268 r274 into r275;
    mul.w r275 r275 into r276;
    lte r276 r0 into r277;
    add r275 1u64 into r278;
    ternary r277 r278 r268 into r279;
    sub r275 1u64 into r280;
    ternary r277 r270 r280 into r281;
    ternary r277 r275 r272 into r282;
    lte r268 r270 into r283;
    ternary r283 r279 r268 into r284;
    lte r284 r270 into r285;
    ternary r285 r281 r270 into r286;
    lte r284 r286 into r287;
    ternary r287 r282 r272 into r288;
    sub.w r286 r284 into r289;
    div r289 2u64 into r290;
    add r284 r290 into r291;
    mul.w r291 r291 into r292;
    lte r292 r0 into r293;
    add r291 1u64 into r294;
    ternary r293 r294 r284 into r295;
    sub r291 1u64 into r296;
    ternary r293 r286 r296 into r297;
    ternary r293 r291 r288 into r298;
    lte r284 r286 into r299;
    ternary r299 r295 r284 into r300;
    lte r300 r286 into r301;
    ternary r301 r297 r286 into r302;
    lte r300 r302 into r303;
    ternary r303 r298 r288 into r304;
    sub.w r302 r300 into r305;
    div r305 2u64 into r306;
    add r300 r306 into r307;
    mul.w r307 r307 into r308;
    lte r308 r0 into r309;
    add r307 1u64 into r310;
    ternary r309 r310 r300 into r311;
    sub r307 1u64 into r312;
    ternary r309 r302 r312 into r313;
    ternary r309 r307 r304 into r314;
    lte r300 r302 into r315;
    ternary r315 r311 r300 into r316;
    lte r316 r302 into r317;
    ternary r317 r313 r302 into r318;
    lte r316 r318 into r319;
    ternary r319 r314 r304 into r320;
    sub.w r318 r316 into r321;
    div r321 2u64 into r322;
    add r316 r322 into r323;
    mul.w r323 r323 into r324;
    lte r324 r0 into r325;
    add r323 1u64 into r326;
    ternary r325 r326 r316 into r327;
    sub r323 1u64 into r328;
    ternary r325 r318 r328 into r329;
    ternary r325 r323 r320 into r330;
    lte r316 r318 into r331;
    ternary r331 r327 r316 into r332;
    lte r332 r318 into r333;
    ternary r333 r329 r318 into r334;
    lte r332 r334 into r335;
    ternary r335 r330 r320 into r336;
    sub.w r334 r332 into r337;
    div r337 2u64 into r338;
    add r332 r338 into r339;
    mul.w r339 r339 into r340;
    lte r340 r0 into r341;
    add r339 1u64 into r342;
    ternary r341 r342 r332 into r343;
    sub r339 1u64 into r344;
    ternary r341 r334 r344 into r345;
    ternary r341 r339 r336 into r346;
    lte r332 r334 into r347;
    ternary r347 r343 r332 into r348;
    lte r348 r334 into r349;
    ternary r349 r345 r334 into r350;
    lte r348 r350 into r351;
    ternary r351 r346 r336 into r352;
    sub.w r350 r348 into r353;
    div r353 2u64 into r354;
    add r348 r354 into r355;
    mul.w r355 r355 into r356;
    lte r356 r0 into r357;
    add r355 1u64 into r358;
    ternary r357 r358 r348 into r359;
    sub r355 1u64 into r360;
    ternary r357 r350 r360 into r361;
    ternary r357 r355 r352 into r362;
    lte r348 r350 into r363;
    ternary r363 r359 r348 into r364;
    lte r364 r350 into r365;
    ternary r365 r361 r350 into r366;
    lte r364 r366 into r367;
    ternary r367 r362 r352 into r368;
    sub.w r366 r364 into r369;
    div r369 2u64 into r370;
    add r364 r370 into r371;
    mul.w r371 r371 into r372;
    lte r372 r0 into r373;
    add r371 1u64 into r374;
    ternary r373 r374 r364 into r375;
    sub r371 1u64 into r376;
    ternary r373 r366 r376 into r377;
    ternary r373 r371 r368 into r378;
    lte r364 r366 into r379;
    ternary r379 r375 r364 into r380;
    lte r380 r366 into r381;
    ternary r381 r377 r366 into r382;
    lte r380 r382 into r383;
    ternary r383 r378 r368 into r384;
    sub.w r382 r380 into r385;
    div r385 2u64 into r386;
    add r380 r386 into r387;
    mul.w r387 r387 into r388;
    lte r388 r0 into r389;
    add r387 1u64 into r390;
    ternary r389 r390 r380 into r391;
    sub r387 1u64 into r392;
    ternary r389 r382 r392 into r393;
    ternary r389 r387 r384 into r394;
    lte r380 r382 into r395;
    ternary r395 r391 r380 into r396;
    lte r396 r382 into r397;
    ternary r397 r393 r382 into r398;
    lte r396 r398 into r399;
    ternary r399 r394 r384 into r400;
    sub.w r398 r396 into r401;
    div r401 2u64 into r402;
    add r396 r402 into r403;
    mul.w r403 r403 into r404;
    lte r404 r0 into r405;
    add r403 1u64 into r406;
    ternary r405 r406 r396 into r407;
    sub r403 1u64 into r408;
    ternary r405 r398 r408 into r409;
    ternary r405 r403 r400 into r410;
    lte r396 r398 into r411;
    ternary r411 r407 r396 into r412;
    lte r412 r398 into r413;
    ternary r413 r409 r398 into r414;
    lte r412 r414 into r415;
    ternary r415 r410 r400 into r416;
    sub.w r414 r412 into r417;
    div r417 2u64 into r418;
    add r412 r418 into r419;
    mul.w r419 r419 into r420;
    lte r420 r0 into r421;
    add r419 1u64 into r422;
    ternary r421 r422 r412 into r423;
    sub r419 1u64 into r424;
    ternary r421 r414 r424 into r425;
    ternary r421 r419 r416 into r426;
    lte r412 r414 into r427;
    ternary r427 r423 r412 into r428;
    lte r428 r414 into r429;
    ternary r429 r425 r414 into r430;
    lte r428 r430 into r431;
    ternary r431 r426 r416 into r432;
    sub.w r430 r428 into r433;
    div r433 2u64 into r434;
    add r428 r434 into r435;
    mul.w r435 r435 into r436;
    lte r436 r0 into r437;
    add r435 1u64 into r438;
    ternary r437 r438 r428 into r439;
    sub r435 1u64 into r440;
    ternary r437 r430 r440 into r441;
    ternary r437 r435 r432 into r442;
    lte r428 r430 into r443;
    ternary r443 r439 r428 into r444;
    lte r444 r430 into r445;
    ternary r445 r441 r430 into r446;
    lte r444 r446 into r447;
    ternary r447 r442 r432 into r448;
    sub.w r446 r444 into r449;
    div r449 2u64 into r450;
    add r444 r450 into r451;
    mul.w r451 r451 into r452;
    lte r452 r0 into r453;
    add r451 1u64 into r454;
    ternary r453 r454 r444 into r455;
    sub r451 1u64 into r456;
    ternary r453 r446 r456 into r457;
    ternary r453 r451 r448 into r458;
    lte r444 r446 into r459;
    ternary r459 r455 r444 into r460;
    lte r460 r446 into r461;
    ternary r461 r457 r446 into r462;
    lte r460 r462 into r463;
    ternary r463 r458 r448 into r464;
    sub.w r462 r460 into r465;
    div r465 2u64 into r466;
    add r460 r466 into r467;
    mul.w r467 r467 into r468;
    lte r468 r0 into r469;
    add r467 1u64 into r470;
    ternary r469 r470 r460 into r471;
    sub r467 1u64 into r472;
    ternary r469 r462 r472 into r473;
    ternary r469 r467 r464 into r474;
    lte r460 r462 into r475;
    ternary r475 r471 r460 into r476;
    lte r476 r462 into r477;
    ternary r477 r473 r462 into r478;
    lte r476 r478 into r479;
    ternary r479 r474 r464 into r480;
    sub.w r478 r476 into r481;
    div r481 2u64 into r482;
    add r476 r482 into r483;
    mul.w r483 r483 into r484;
    lte r484 r0 into r485;
    add r483 1u64 into r486;
    ternary r485 r486 r476 into r487;
    sub r483 1u64 into r488;
    ternary r485 r478 r488 into r489;
    ternary r485 r483 r480 into r490;
    lte r476 r478 into r491;
    ternary r491 r487 r476 into r492;
    lte r492 r478 into r493;
    ternary r493 r489 r478 into r494;
    lte r492 r494 into r495;
    ternary r495 r490 r480 into r496;
    sub.w r494 r492 into r497;
    div r497 2u64 into r498;
    add r492 r498 into r499;
    mul.w r499 r499 into r500;
    lte r500 r0 into r501;
    add r499 1u64 into r502;
    ternary r501 r502 r492 into r503;
    sub r499 1u64 into r504;
    ternary r501 r494 r504 into r505;
    ternary r501 r499 r496 into r506;
    lte r492 r494 into r507;
    ternary r507 r503 r492 into r508;
    lte r508 r494 into r509;
    ternary r509 r505 r494 into r510;
    lte r508 r510 into r511;
    ternary r511 r506 r496 into r512;
    sub.w r510 r508 into r513;
    div r513 2u64 into r514;
    add r508 r514 into r515;
    mul.w r515 r515 into r516;
    lte r516 r0 into r517;
    add r515 1u64 into r518;
    ternary r517 r518 r508 into r519;
    sub r515 1u64 into r520;
    ternary r517 r510 r520 into r521;
    ternary r517 r515 r512 into r522;
    lte r508 r510 into r523;
    ternary r523 r519 r508 into r524;
    lte r524 r510 into r525;
    ternary r525 r521 r510 into r526;
    lte r524 r526 into r527;
    ternary r527 r522 r512 into r528;
    sub.w r526 r524 into r529;
    div r529 2u64 into r530;
    add r524 r530 into r531;
    mul.w r531 r531 into r532;
    lte r532 r0 into r533;
    add r531 1u64 into r534;
    ternary r533 r534 r524 into r535;
    sub r531 1u64 into r536;
    ternary r533 r526 r536 into r537;
    ternary r533 r531 r528 into r538;
    lte r524 r526 into r539;
    ternary r539 r535 r524 into r540;
    lte r540 r526 into r541;
    ternary r541 r537 r526 into r542;
    lte r540 r542 into r543;
    ternary r543 r538 r528 into r544;
    sub.w r542 r540 into r545;
    div r545 2u64 into r546;
    add r540 r546 into r547;
    mul.w r547 r547 into r548;
    lte r548 r0 into r549;
    add r547 1u64 into r550;
    ternary r549 r550 r540 into r551;
    sub r547 1u64 into r552;
    ternary r549 r542 r552 into r553;
    ternary r549 r547 r544 into r554;
    lte r540 r542 into r555;
    ternary r555 r551 r540 into r556;
    lte r556 r542 into r557;
    ternary r557 r553 r542 into r558;
    lte r556 r558 into r559;
    ternary r559 r554 r544 into r560;
    sub.w r558 r556 into r561;
    div r561 2u64 into r562;
    add r556 r562 into r563;
    mul.w r563 r563 into r564;
    lte r564 r0 into r565;
    add r563 1u64 into r566;
    ternary r565 r566 r556 into r567;
    sub r563 1u64 into r568;
    ternary r565 r558 r568 into r569;
    ternary r565 r563 r560 into r570;
    lte r556 r558 into r571;
    ternary r571 r567 r556 into r572;
    lte r572 r558 into r573;
    ternary r573 r569 r558 into r574;
    lte r572 r574 into r575;
    ternary r575 r570 r560 into r576;
    sub.w r574 r572 into r577;
    div r577 2u64 into r578;
    add r572 r578 into r579;
    mul.w r579 r579 into r580;
    lte r580 r0 into r581;
    add r579 1u64 into r582;
    ternary r581 r582 r572 into r583;
    sub r579 1u64 into r584;
    ternary r581 r574 r584 into r585;
    ternary r581 r579 r576 into r586;
    lte r572 r574 into r587;
    ternary r587 r583 r572 into r588;
    lte r588 r574 into r589;
    ternary r589 r585 r574 into r590;
    lte r588 r590 into r591;
    ternary r591 r586 r576 into r592;
    sub.w r590 r588 into r593;
    div r593 2u64 into r594;
    add r588 r594 into r595;
    mul.w r595 r595 into r596;
    lte r596 r0 into r597;
    add r595 1u64 into r598;
    ternary r597 r598 r588 into r599;
    sub r595 1u64 into r600;
    ternary r597 r590 r600 into r601;
    ternary r597 r595 r592 into r602;
    lte r588 r590 into r603;
    ternary r603 r599 r588 into r604;
    lte r604 r590 into r605;
    ternary r605 r601 r590 into r606;
    lte r604 r606 into r607;
    ternary r607 r602 r592 into r608;
    output r608 as u64;

function mint_private:
    input r0 as tokenA.record;
    input r1 as u64.private;
    input r2 as tokenB.record;
    input r3 as u64.private;
    sub r0.amount r1 into r4;
    gte r4 0u64 into r5;
    assert.eq r5 true ;
    sub r2.amount r3 into r6;
    gte r6 0u64 into r7;
    assert.eq r7 true ;
    sub r0.amount r1 into r8;
    cast r0.owner r8 into r9 as tokenA.record;
    sub r2.amount r3 into r10;
    cast r2.owner r10 into r11 as tokenB.record;
    mul r1 r3 into r12;
    call square_root r12 into r13;
    cast self.caller r13 into r14 as LiquidityPool.record;
    async mint_private self.caller r13 r1 r3 into r15;
    output r9 as tokenA.record;
    output r11 as tokenB.record;
    output r14 as LiquidityPool.record;
    output r15 as uniswap_v5.aleo/mint_private.future;

finalize mint_private:
    input r0 as address.public;
    input r1 as u64.public;
    input r2 as u64.public;
    input r3 as u64.public;
    cast 0u64 0u64 false 1000u64 1u64 1u64 into r4 as Config;
    get.or_use config[1field] r4 into r5;
    mul.w r2 r5.total_supply into r6;
    div.w r6 r5.reserve_a into r7;
    mul.w r3 r5.total_supply into r8;
    div.w r8 r5.reserve_b into r9;
    gt r7 r9 into r10;
    ternary r10 r9 r7 into r11;
    is.eq r5.total_supply 0u64 into r12;
    gte r1 10u64 into r13;
    not r12 into r14;
    or r14 r13 into r15;
    assert.eq r15 true ;
    add r5.total_supply r11 into r16;
    ternary r12 r1 r16 into r17;
    mul r2 r3 into r18;
    ternary r12 0u64 r18 into r19;
    ternary r12 false r5.lock into r20;
    add r5.reserve_a r2 into r21;
    ternary r12 r2 r21 into r22;
    add r5.reserve_b r3 into r23;
    ternary r12 r3 r23 into r24;
    cast r17 r19 r20 10u64 r22 r24 into r25 as Config;
    set r25 into config[1field];

function mint_private_to_public:
    input r0 as LiquidityPool.record;
    input r1 as u64.public;
    sub r0.amount r1 into r2;
    gte r2 0u64 into r3;
    assert.eq r3 true ;
    sub r0.amount r1 into r4;
    cast r0.owner r4 into r5 as LiquidityPool.record;
    async mint_private_to_public self.caller r1 into r6;
    output r5 as LiquidityPool.record;
    output r6 as uniswap_v5.aleo/mint_private_to_public.future;

finalize mint_private_to_public:
    input r0 as address.public;
    input r1 as u64.public;
    get.or_use account[r0] 0u64 into r2;
    add r2 r1 into r3;
    set r3 into account[r0];

function mint_public:
    input r0 as tokenA.record;
    input r1 as u64.public;
    input r2 as tokenB.record;
    input r3 as u64.public;
    sub r0.amount r1 into r4;
    gte r4 0u64 into r5;
    assert.eq r5 true ;
    sub r2.amount r3 into r6;
    gte r6 0u64 into r7;
    assert.eq r7 true ;
    sub r0.amount r1 into r8;
    cast r0.owner r8 into r9 as tokenA.record;
    sub r2.amount r3 into r10;
    cast r2.owner r10 into r11 as tokenB.record;
    mul r1 r3 into r12;
    call square_root r12 into r13;
    async mint_public self.caller r13 r1 r3 into r14;
    output r9 as tokenA.record;
    output r11 as tokenB.record;
    output r14 as uniswap_v5.aleo/mint_public.future;

finalize mint_public:
    input r0 as address.public;
    input r1 as u64.public;
    input r2 as u64.public;
    input r3 as u64.public;
    cast 0u64 0u64 false 1000u64 1u64 1u64 into r4 as Config;
    get.or_use config[1field] r4 into r5;
    mul.w r2 r5.total_supply into r6;
    div.w r6 r5.reserve_a into r7;
    mul.w r3 r5.total_supply into r8;
    div.w r8 r5.reserve_b into r9;
    gt r7 r9 into r10;
    ternary r10 r9 r7 into r11;
    is.eq r5.total_supply 0u64 into r12;
    get.or_use account[r0] 0u64 into r13;
    not r12 into r14;
    ternary r14 0u64 10u64 into r15;
    sub r1 r15 into r16;
    add r13 r11 into r17;
    ternary r12 r16 r17 into r18;
    set r18 into account[r0];
    add r5.total_supply r11 into r19;
    ternary r12 r1 r19 into r20;
    mul r2 r3 into r21;
    ternary r12 0u64 r21 into r22;
    ternary r12 false r5.lock into r23;
    add r5.reserve_a r2 into r24;
    ternary r12 r2 r24 into r25;
    add r5.reserve_b r3 into r26;
    ternary r12 r3 r26 into r27;
    cast r20 r22 r23 r15 r25 r27 into r28 as Config;
    set r28 into config[1field];

function burn_public:
    input r0 as address.public;
    input r1 as u64.public;
    input r2 as u64.public;
    cast r0 r1 into r3 as tokenA.record;
    cast r0 r2 into r4 as tokenB.record;
    mul r1 r2 into r5;
    call square_root r5 into r6;
    async burn_public self.caller r1 r2 r6 into r7;
    output r3 as tokenA.record;
    output r4 as tokenB.record;
    output r7 as uniswap_v5.aleo/burn_public.future;

finalize burn_public:
    input r0 as address.public;
    input r1 as u64.public;
    input r2 as u64.public;
    input r3 as u64.public;
    cast 0u64 0u64 false 1000u64 1u64 1u64 into r4 as Config;
    get.or_use config[1field] r4 into r5;
    gte r5.reserve_a r1 into r6;
    assert.eq r6 true ;
    gte r5.reserve_b r2 into r7;
    assert.eq r7 true ;
    get.or_use account[r0] 0u64 into r8;
    mul r8 r5.reserve_a into r9;
    div r9 r5.total_supply into r10;
    mul r8 r5.reserve_b into r11;
    div r11 r5.total_supply into r12;
    gte r10 r1 into r13;
    assert.eq r13 true ;
    gte r12 r2 into r14;
    assert.eq r14 true ;
    gte r8 r3 into r15;
    assert.eq r15 true ;
    sub r5.total_supply r3 into r16;
    sub r8 r3 into r17;
    set r17 into account[r0];
    sub r5.reserve_a r1 into r18;
    sub r5.reserve_b r2 into r19;
    cast r16 r5.k_last r5.lock r5.minimum_liquidity r18 r19 into r20 as Config;
    set r20 into config[1field];

function swap_a_to_b_private:
    input r0 as address.private;
    input r1 as tokenA.record;
    input r2 as u64.private;
    input r3 as u64.private;
    sub r1.amount r2 into r4;
    gte r4 0u64 into r5;
    assert.eq r5 true ;
    sub r1.amount r2 into r6;
    cast r1.owner r6 into r7 as tokenA.record;
    cast r0 r3 into r8 as tokenB.record;
    async swap_a_to_b_private r2 r3 into r9;
    output r7 as tokenA.record;
    output r8 as tokenB.record;
    output r9 as uniswap_v5.aleo/swap_a_to_b_private.future;

finalize swap_a_to_b_private:
    input r0 as u64.public;
    input r1 as u64.public;
    cast 0u64 0u64 false 1000u64 1u64 1u64 into r2 as Config;
    get.or_use config[1field] r2 into r3;
    gte r3.reserve_b r1 into r4;
    assert.eq r4 true ;
    add r3.reserve_a r0 into r5;
    sub r3.reserve_b r1 into r6;
    mul r5 1000u64 into r7;
    mul r0 3u64 into r8;
    sub r7 r8 into r9;
    mul r6 1000u64 into r10;
    mul r1 3u64 into r11;
    sub r10 r11 into r12;
    mul r9 r12 into r13;
    mul r3.reserve_a r3.reserve_b into r14;
    mul r14 1000000u64 into r15;
    gte r13 r15 into r16;
    assert.eq r16 true ;
    cast r3.total_supply r3.k_last r3.lock r3.minimum_liquidity r5 r6 into r17 as Config;
    set r17 into config[1field];

function swap_a_to_b_public:
    input r0 as address.public;
    input r1 as u64.public;
    input r2 as u64.public;
    async swap_a_to_b_public self.caller r0 r1 r2 into r3;
    output r3 as uniswap_v5.aleo/swap_a_to_b_public.future;

finalize swap_a_to_b_public:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as u64.public;
    input r3 as u64.public;
    get.or_use account_a[r0] 0u64 into r4;
    gte r4 r2 into r5;
    assert.eq r5 true ;
    sub r4 r2 into r6;
    set r6 into account_a[r0];
    get.or_use account_b[r1] 0u64 into r7;
    add r7 r3 into r8;
    set r8 into account_b[r1];
    cast 0u64 0u64 false 1000u64 1u64 1u64 into r9 as Config;
    get.or_use config[1field] r9 into r10;
    gte r10.reserve_b r3 into r11;
    assert.eq r11 true ;
    add r10.reserve_a r2 into r12;
    sub r10.reserve_b r3 into r13;
    mul r12 1000u64 into r14;
    mul r2 3u64 into r15;
    sub r14 r15 into r16;
    mul r13 1000u64 into r17;
    mul r3 3u64 into r18;
    sub r17 r18 into r19;
    mul r16 r19 into r20;
    mul r10.reserve_a r10.reserve_b into r21;
    mul r21 1000000u64 into r22;
    gte r20 r22 into r23;
    assert.eq r23 true ;
    cast r10.total_supply r10.k_last r10.lock r10.minimum_liquidity r12 r13 into r24 as Config;
    set r24 into config[1field];

function swap_b_to_a_private:
    input r0 as address.private;
    input r1 as tokenB.record;
    input r2 as u64.private;
    input r3 as u64.private;
    sub r1.amount r2 into r4;
    gte r4 0u64 into r5;
    assert.eq r5 true ;
    sub r1.amount r2 into r6;
    cast r1.owner r6 into r7 as tokenB.record;
    cast r0 r3 into r8 as tokenA.record;
    async swap_b_to_a_private self.caller r2 r3 into r9;
    output r7 as tokenB.record;
    output r8 as tokenA.record;
    output r9 as uniswap_v5.aleo/swap_b_to_a_private.future;

finalize swap_b_to_a_private:
    input r0 as address.public;
    input r1 as u64.public;
    input r2 as u64.public;
    cast 0u64 0u64 false 1000u64 1u64 1u64 into r3 as Config;
    get.or_use config[1field] r3 into r4;
    gte r4.reserve_a r2 into r5;
    assert.eq r5 true ;
    sub r4.reserve_a r2 into r6;
    add r4.reserve_b r1 into r7;
    mul r6 1000u64 into r8;
    mul r2 3u64 into r9;
    sub r8 r9 into r10;
    mul r7 1000u64 into r11;
    mul r1 3u64 into r12;
    sub r11 r12 into r13;
    mul r10 r13 into r14;
    mul r4.reserve_a r4.reserve_b into r15;
    mul r15 1000000u64 into r16;
    gte r14 r16 into r17;
    assert.eq r17 true ;
    cast r4.total_supply r4.k_last r4.lock r4.minimum_liquidity r6 r7 into r18 as Config;
    set r18 into config[1field];

function swap_b_to_a_public:
    input r0 as address.public;
    input r1 as u64.public;
    input r2 as u64.public;
    async swap_b_to_a_public self.caller r0 r1 r2 into r3;
    output r3 as uniswap_v5.aleo/swap_b_to_a_public.future;

finalize swap_b_to_a_public:
    input r0 as address.public;
    input r1 as address.public;
    input r2 as u64.public;
    input r3 as u64.public;
    get.or_use account_b[r0] 0u64 into r4;
    gte r4 r2 into r5;
    assert.eq r5 true ;
    sub r4 r2 into r6;
    set r6 into account_b[r0];
    get.or_use account_a[r1] 0u64 into r7;
    add r7 r3 into r8;
    set r8 into account_a[r1];
    cast 0u64 0u64 false 1000u64 1u64 1u64 into r9 as Config;
    get.or_use config[1field] r9 into r10;
    gte r10.reserve_a r3 into r11;
    assert.eq r11 true ;
    sub r10.reserve_a r3 into r12;
    add r10.reserve_b r2 into r13;
    mul r12 1000u64 into r14;
    mul r3 3u64 into r15;
    sub r14 r15 into r16;
    mul r13 1000u64 into r17;
    mul r2 3u64 into r18;
    sub r17 r18 into r19;
    mul r16 r19 into r20;
    mul r10.reserve_a r10.reserve_b into r21;
    mul r21 1000000u64 into r22;
    gte r20 r22 into r23;
    assert.eq r23 true ;
    cast r10.total_supply r10.k_last r10.lock r10.minimum_liquidity r12 r13 into r24 as Config;
    set r24 into config[1field];
