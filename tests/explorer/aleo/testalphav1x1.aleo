program testalphav1x1.aleo;

record PrivateToken:
    owner as address.private;
    token as field.private;
    amount as u128.private;

struct TokenInfo:
    name as field;
    symbol as field;
    decimals as u8;
    total_supply as u128;
    admin as address;
    mintable as boolean;
    burnable as boolean;

struct GlobalState:
    admin as address;
    fee_to as address;

struct Pair:
    reserve_a as u128;
    reserve_b as u128;
    last_k as u128;

struct BalanceKeyData:
    token as field;
    user as address;

struct AllowanceKeyData:
    token as field;
    payer as address;
    spender as address;

struct PairKeyData:
    token_a as field;
    token_b as field;

struct TokenIdData:
    base as address;
    creator as address;
    salt as u128;

mapping balances:
    key as field.public;
    value as u128.public;

mapping allowance:
    key as field.public;
    value as u128.public;

mapping tokens:
    key as field.public;
    value as TokenInfo.public;

mapping global_state:
    key as boolean.public;
    value as GlobalState.public;

mapping pairs:
    key as field.public;
    value as Pair.public;

function create_token:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as boolean.public;
    input r6 as boolean.public;
    input r7 as u128.public;
    gt r0 0field into r8;
    assert.eq r8 true ;
    async create_token r0 r1 r2 r3 r4 r5 r6 self.caller r7 into r9;
    output r9 as testalphav1x1.aleo/create_token.future;

finalize create_token:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as boolean.public;
    input r6 as boolean.public;
    input r7 as address.public;
    input r8 as u128.public;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r7 r8 into r9 as TokenIdData;
    hash.bhp256 r9 into r10 as field;
    contains tokens[r10] into r11;
    not r11 into r12;
    assert.eq r12 true ;
    cast r0 r1 r2 r3 r4 r5 r6 into r13 as TokenInfo;
    set r13 into tokens[r10];
    cast r10 r7 into r14 as BalanceKeyData;
    hash.bhp256 r14 into r15 as field;
    set r13.total_supply into balances[r15];

function transfer_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async transfer_public r0 self.caller r1 r2 into r3;
    output r3 as testalphav1x1.aleo/transfer_public.future;

finalize transfer_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    contains tokens[r0] into r4;
    assert.eq r4 true ;
    cast r0 r1 into r5 as BalanceKeyData;
    hash.bhp256 r5 into r6 as field;
    get balances[r6] into r7;
    sub r7 r3 into r8;
    set r8 into balances[r6];
    cast r0 r2 into r9 as BalanceKeyData;
    hash.bhp256 r9 into r10 as field;
    get.or_use balances[r10] 0u128 into r11;
    add r11 r3 into r12;
    set r12 into balances[r10];

function approve:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async approve r0 self.caller r1 r2 into r3;
    output r3 as testalphav1x1.aleo/approve.future;

finalize approve:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    contains tokens[r0] into r4;
    assert.eq r4 true ;
    cast r0 r1 r2 into r5 as AllowanceKeyData;
    hash.bhp256 r5 into r6 as field;
    set r3 into allowance[r6];

function transfer_from:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    async transfer_from self.caller r0 r1 r2 r3 into r4;
    output r4 as testalphav1x1.aleo/transfer_from.future;

finalize transfer_from:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as address.public;
    input r4 as u128.public;
    contains tokens[r1] into r5;
    assert.eq r5 true ;
    cast r1 r2 r0 into r6 as AllowanceKeyData;
    hash.bhp256 r6 into r7 as field;
    get allowance[r7] into r8;
    sub r8 r4 into r9;
    set r9 into allowance[r7];
    cast r1 r2 into r10 as BalanceKeyData;
    hash.bhp256 r10 into r11 as field;
    get balances[r11] into r12;
    sub r12 r4 into r13;
    set r13 into balances[r11];
    cast r1 r3 into r14 as BalanceKeyData;
    hash.bhp256 r14 into r15 as field;
    get.or_use balances[r15] 0u128 into r16;
    add r16 r4 into r17;
    set r17 into balances[r15];

function transfer_private:
    input r0 as PrivateToken.record;
    input r1 as address.private;
    input r2 as u128.private;
    cast r1 r0.token r2 into r3 as PrivateToken.record;
    sub r0.amount r2 into r4;
    cast r0.owner r0.token r4 into r5 as PrivateToken.record;
    output r3 as PrivateToken.record;
    output r5 as PrivateToken.record;

function transfer_public_to_private:
    input r0 as field.public;
    input r1 as address.private;
    input r2 as u128.public;
    cast r1 r0 r2 into r3 as PrivateToken.record;
    async transfer_public_to_private r0 self.caller r2 into r4;
    output r3 as PrivateToken.record;
    output r4 as testalphav1x1.aleo/transfer_public_to_private.future;

finalize transfer_public_to_private:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true ;
    cast r0 r1 into r4 as BalanceKeyData;
    hash.bhp256 r4 into r5 as field;
    get balances[r5] into r6;
    sub r6 r2 into r7;
    set r7 into balances[r5];

function transfer_private_to_public:
    input r0 as PrivateToken.record;
    input r1 as address.public;
    input r2 as u128.public;
    sub r0.amount r2 into r3;
    cast r0.owner r0.token r3 into r4 as PrivateToken.record;
    async transfer_private_to_public r0.token r1 r2 into r5;
    output r4 as PrivateToken.record;
    output r5 as testalphav1x1.aleo/transfer_private_to_public.future;

finalize transfer_private_to_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true ;
    cast r0 r1 into r4 as BalanceKeyData;
    hash.bhp256 r4 into r5 as field;
    get.or_use balances[r5] 0u128 into r6;
    add r6 r2 into r7;
    set r7 into balances[r5];

function join:
    input r0 as PrivateToken.record;
    input r1 as PrivateToken.record;
    assert.eq r0.token r1.token ;
    add r0.amount r1.amount into r2;
    cast r0.owner r0.token r2 into r3 as PrivateToken.record;
    output r3 as PrivateToken.record;

function change_token_admin:
    input r0 as field.public;
    input r1 as address.public;
    async change_token_admin self.caller r0 r1 into r2;
    output r2 as testalphav1x1.aleo/change_token_admin.future;

finalize change_token_admin:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    get tokens[r1] into r3;
    assert.eq r0 r3.admin ;
    cast r3.name r3.symbol r3.decimals r3.total_supply r2 r3.mintable r3.burnable into r4 as TokenInfo;
    set r4 into tokens[r1];

function renounce_mintable:
    input r0 as field.public;
    async renounce_mintable self.caller r0 into r1;
    output r1 as testalphav1x1.aleo/renounce_mintable.future;

finalize renounce_mintable:
    input r0 as address.public;
    input r1 as field.public;
    get tokens[r1] into r2;
    assert.eq r0 r2.admin ;
    assert.eq r2.mintable true ;
    cast r2.name r2.symbol r2.decimals r2.total_supply r2.admin false r2.burnable into r3 as TokenInfo;
    set r3 into tokens[r1];

function renounce_burnable:
    input r0 as field.public;
    async renounce_burnable self.caller r0 into r1;
    output r1 as testalphav1x1.aleo/renounce_burnable.future;

finalize renounce_burnable:
    input r0 as address.public;
    input r1 as field.public;
    get tokens[r1] into r2;
    assert.eq r0 r2.admin ;
    assert.eq r2.burnable true ;
    cast r2.name r2.symbol r2.decimals r2.total_supply r2.admin r2.mintable false into r3 as TokenInfo;
    set r3 into tokens[r1];

function mint_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async mint_public self.caller r0 r1 r2 into r3;
    output r3 as testalphav1x1.aleo/mint_public.future;

finalize mint_public:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as u128.public;
    get tokens[r1] into r4;
    assert.eq r0 r4.admin ;
    assert.eq r4.mintable true ;
    add r4.total_supply r3 into r5;
    cast r4.name r4.symbol r4.decimals r5 r4.admin r4.mintable r4.burnable into r6 as TokenInfo;
    set r6 into tokens[r1];
    cast r1 r2 into r7 as BalanceKeyData;
    hash.bhp256 r7 into r8 as field;
    get.or_use balances[r8] 0u128 into r9;
    add r9 r3 into r10;
    set r10 into balances[r8];

function mint_private:
    input r0 as field.public;
    input r1 as address.private;
    input r2 as u128.public;
    cast r1 r0 r2 into r3 as PrivateToken.record;
    async mint_private self.caller r0 r2 into r4;
    output r3 as PrivateToken.record;
    output r4 as testalphav1x1.aleo/mint_private.future;

finalize mint_private:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    get tokens[r1] into r3;
    assert.eq r0 r3.admin ;
    assert.eq r3.mintable true ;
    add r3.total_supply r2 into r4;
    cast r3.name r3.symbol r3.decimals r4 r3.admin r3.mintable r3.burnable into r5 as TokenInfo;
    set r5 into tokens[r1];

function burn:
    input r0 as field.public;
    input r1 as u128.public;
    async burn self.caller r0 r1 into r2;
    output r2 as testalphav1x1.aleo/burn.future;

finalize burn:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    get tokens[r1] into r3;
    assert.eq r3.burnable true ;
    sub r3.total_supply r2 into r4;
    cast r3.name r3.symbol r3.decimals r4 r3.admin r3.mintable r3.burnable into r5 as TokenInfo;
    set r5 into tokens[r1];
    cast r1 r0 into r6 as BalanceKeyData;
    hash.bhp256 r6 into r7 as field;
    get balances[r7] into r8;
    sub r8 r2 into r9;
    set r9 into balances[r7];

function burn_from:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async burn_from self.caller r0 r1 r2 into r3;
    output r3 as testalphav1x1.aleo/burn_from.future;

finalize burn_from:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as u128.public;
    get tokens[r1] into r4;
    assert.eq r4.burnable true ;
    cast r1 r2 r0 into r5 as AllowanceKeyData;
    hash.bhp256 r5 into r6 as field;
    get allowance[r6] into r7;
    sub r7 r3 into r8;
    set r8 into allowance[r6];
    sub r4.total_supply r3 into r9;
    cast r4.name r4.symbol r4.decimals r9 r4.admin r4.mintable r4.burnable into r10 as TokenInfo;
    set r10 into tokens[r1];
    cast r1 r2 into r11 as BalanceKeyData;
    hash.bhp256 r11 into r12 as field;
    get balances[r12] into r13;
    sub r13 r3 into r14;
    set r14 into balances[r12];

function init:
    input r0 as address.private;
    assert.eq self.caller aleo1uldp2afc9gnfsxd0r2svaecax8quutny5j6ns2qa80yp5uhsac9q35h7h6 ;
    async init r0 into r1;
    output r1 as testalphav1x1.aleo/init.future;

finalize init:
    input r0 as address.public;
    contains global_state[true] into r1;
    not r1 into r2;
    assert.eq r2 true ;
    cast r0 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r3 as GlobalState;
    set r3 into global_state[true];

function change_admin:
    input r0 as address.public;
    async change_admin self.caller r0 into r1;
    output r1 as testalphav1x1.aleo/change_admin.future;

finalize change_admin:
    input r0 as address.public;
    input r1 as address.public;
    get global_state[true] into r2;
    assert.eq r0 r2.admin ;
    cast r1 r2.fee_to into r3 as GlobalState;
    set r3 into global_state[true];

function set_fee_to:
    input r0 as address.public;
    async set_fee_to self.caller r0 into r1;
    output r1 as testalphav1x1.aleo/set_fee_to.future;

finalize set_fee_to:
    input r0 as address.public;
    input r1 as address.public;
    get global_state[true] into r2;
    assert.eq r0 r2.admin ;
    cast r2.admin r1 into r3 as GlobalState;
    set r3 into global_state[true];

function create_pair:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    async create_pair self.caller r0 r1 r2 r3 r4 into r8;
    output r8 as testalphav1x1.aleo/create_pair.future;

finalize create_pair:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r1 r2 into r6;
    assert.eq r6 true ;
    cast r1 r2 into r7 as PairKeyData;
    hash.bhp256 r7 into r8 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r8 into r9 as TokenIdData;
    hash.bhp256 r9 into r10 as field;
    contains pairs[r10] into r11;
    not r11 into r12;
    assert.eq r12 true ;
    contains tokens[r10] into r13;
    not r13 into r14;
    assert.eq r14 true ;
    mul r3 r4 into r15;
    is.eq r15 0u128 into r16;
    is.eq r15 0u128 into r17;
    ternary r17 1u128 r15 into r18;
    shr r18 64u32 into r19;
    gt r19 0u128 into r20;
    shr r18 64u32 into r21;
    add 0u32 64u32 into r22;
    ternary r20 r21 r18 into r23;
    ternary r20 r22 0u32 into r24;
    shr r23 32u32 into r25;
    gt r25 0u128 into r26;
    shr r23 32u32 into r27;
    add r24 32u32 into r28;
    ternary r26 r27 r23 into r29;
    ternary r26 r28 r24 into r30;
    shr r29 16u32 into r31;
    gt r31 0u128 into r32;
    shr r29 16u32 into r33;
    add r30 16u32 into r34;
    ternary r32 r33 r29 into r35;
    ternary r32 r34 r30 into r36;
    shr r35 8u32 into r37;
    gt r37 0u128 into r38;
    shr r35 8u32 into r39;
    add r36 8u32 into r40;
    ternary r38 r39 r35 into r41;
    ternary r38 r40 r36 into r42;
    shr r41 4u32 into r43;
    gt r43 0u128 into r44;
    shr r41 4u32 into r45;
    add r42 4u32 into r46;
    ternary r44 r45 r41 into r47;
    ternary r44 r46 r42 into r48;
    shr r47 2u32 into r49;
    gt r49 0u128 into r50;
    shr r47 2u32 into r51;
    add r48 2u32 into r52;
    ternary r50 r51 r47 into r53;
    ternary r50 r52 r48 into r54;
    shr r53 1u32 into r55;
    gt r55 0u128 into r56;
    add r54 1u32 into r57;
    ternary r56 r57 r54 into r58;
    div r58 2u32 into r59;
    shl 1u128 r59 into r60;
    div r18 r60 into r61;
    add r60 r61 into r62;
    shr r62 1u32 into r63;
    div r18 r63 into r64;
    add r63 r64 into r65;
    shr r65 1u32 into r66;
    div r18 r66 into r67;
    add r66 r67 into r68;
    shr r68 1u32 into r69;
    div r18 r69 into r70;
    add r69 r70 into r71;
    shr r71 1u32 into r72;
    div r18 r72 into r73;
    add r72 r73 into r74;
    shr r74 1u32 into r75;
    div r18 r75 into r76;
    add r75 r76 into r77;
    shr r77 1u32 into r78;
    div r18 r78 into r79;
    add r78 r79 into r80;
    shr r80 1u32 into r81;
    div r18 r81 into r82;
    lt r81 r82 into r83;
    ternary r83 r81 r82 into r84;
    ternary r16 0u128 r84 into r85;
    gt r85 1000u128 into r86;
    assert.eq r86 true ;
    cast r1 r0 into r87 as BalanceKeyData;
    hash.bhp256 r87 into r88 as field;
    get balances[r88] into r89;
    sub r89 r3 into r90;
    set r90 into balances[r88];
    cast r2 r0 into r91 as BalanceKeyData;
    hash.bhp256 r91 into r92 as field;
    get balances[r92] into r93;
    sub r93 r4 into r94;
    set r94 into balances[r92];
    get global_state[true] into r95;
    is.eq r95.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r96;
    mul r3 r4 into r97;
    ternary r96 0u128 r97 into r98;
    cast r3 r4 r98 into r99 as Pair;
    set r99 into pairs[r10];
    cast 5183377571718029925300968712562field 4281168field 6u8 r85 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc false false into r100 as TokenInfo;
    set r100 into tokens[r10];
    cast r10 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r101 as BalanceKeyData;
    hash.bhp256 r101 into r102 as field;
    get.or_use balances[r102] 0u128 into r103;
    add r103 1000u128 into r104;
    set r104 into balances[r102];
    cast r10 r5 into r105 as BalanceKeyData;
    hash.bhp256 r105 into r106 as field;
    get.or_use balances[r106] 0u128 into r107;
    add r107 r85 into r108;
    sub r108 1000u128 into r109;
    set r109 into balances[r106];

function create_pair_privately:
    input r0 as PrivateToken.record;
    input r1 as PrivateToken.record;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.private;
    input r5 as u128.public;
    lt r0.token r1.token into r6;
    assert.eq r6 true ;
    gt r2 0u128 into r7;
    assert.eq r7 true ;
    gt r3 0u128 into r8;
    assert.eq r8 true ;
    gt r5 1000u128 into r9;
    assert.eq r9 true ;
    sub r0.amount r2 into r10;
    cast r0.owner r0.token r10 into r11 as PrivateToken.record;
    sub r1.amount r3 into r12;
    cast r1.owner r1.token r12 into r13 as PrivateToken.record;
    lt r0.token r1.token into r14;
    assert.eq r14 true ;
    cast r0.token r1.token into r15 as PairKeyData;
    hash.bhp256 r15 into r16 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r16 into r17 as TokenIdData;
    hash.bhp256 r17 into r18 as field;
    sub r5 1000u128 into r19;
    cast r4 r18 r19 into r20 as PrivateToken.record;
    async create_pair_privately r0.token r1.token r2 r3 r18 r5 into r21;
    output r20 as PrivateToken.record;
    output r11 as PrivateToken.record;
    output r13 as PrivateToken.record;
    output r21 as testalphav1x1.aleo/create_pair_privately.future;

finalize create_pair_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as field.public;
    input r5 as u128.public;
    contains pairs[r4] into r6;
    not r6 into r7;
    assert.eq r7 true ;
    contains tokens[r4] into r8;
    not r8 into r9;
    assert.eq r9 true ;
    mul r2 r3 into r10;
    is.eq r10 0u128 into r11;
    is.eq r10 0u128 into r12;
    ternary r12 1u128 r10 into r13;
    shr r13 64u32 into r14;
    gt r14 0u128 into r15;
    shr r13 64u32 into r16;
    add 0u32 64u32 into r17;
    ternary r15 r16 r13 into r18;
    ternary r15 r17 0u32 into r19;
    shr r18 32u32 into r20;
    gt r20 0u128 into r21;
    shr r18 32u32 into r22;
    add r19 32u32 into r23;
    ternary r21 r22 r18 into r24;
    ternary r21 r23 r19 into r25;
    shr r24 16u32 into r26;
    gt r26 0u128 into r27;
    shr r24 16u32 into r28;
    add r25 16u32 into r29;
    ternary r27 r28 r24 into r30;
    ternary r27 r29 r25 into r31;
    shr r30 8u32 into r32;
    gt r32 0u128 into r33;
    shr r30 8u32 into r34;
    add r31 8u32 into r35;
    ternary r33 r34 r30 into r36;
    ternary r33 r35 r31 into r37;
    shr r36 4u32 into r38;
    gt r38 0u128 into r39;
    shr r36 4u32 into r40;
    add r37 4u32 into r41;
    ternary r39 r40 r36 into r42;
    ternary r39 r41 r37 into r43;
    shr r42 2u32 into r44;
    gt r44 0u128 into r45;
    shr r42 2u32 into r46;
    add r43 2u32 into r47;
    ternary r45 r46 r42 into r48;
    ternary r45 r47 r43 into r49;
    shr r48 1u32 into r50;
    gt r50 0u128 into r51;
    add r49 1u32 into r52;
    ternary r51 r52 r49 into r53;
    div r53 2u32 into r54;
    shl 1u128 r54 into r55;
    div r13 r55 into r56;
    add r55 r56 into r57;
    shr r57 1u32 into r58;
    div r13 r58 into r59;
    add r58 r59 into r60;
    shr r60 1u32 into r61;
    div r13 r61 into r62;
    add r61 r62 into r63;
    shr r63 1u32 into r64;
    div r13 r64 into r65;
    add r64 r65 into r66;
    shr r66 1u32 into r67;
    div r13 r67 into r68;
    add r67 r68 into r69;
    shr r69 1u32 into r70;
    div r13 r70 into r71;
    add r70 r71 into r72;
    shr r72 1u32 into r73;
    div r13 r73 into r74;
    add r73 r74 into r75;
    shr r75 1u32 into r76;
    div r13 r76 into r77;
    lt r76 r77 into r78;
    ternary r78 r76 r77 into r79;
    ternary r11 0u128 r79 into r80;
    is.eq r5 r80 into r81;
    assert.eq r81 true ;
    get global_state[true] into r82;
    is.eq r82.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r83;
    mul r2 r3 into r84;
    ternary r83 0u128 r84 into r85;
    cast r2 r3 r85 into r86 as Pair;
    set r86 into pairs[r4];
    cast 5183377571718029925300968712562field 4281168field 6u8 r80 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc false false into r87 as TokenInfo;
    set r87 into tokens[r4];
    cast r4 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r88 as BalanceKeyData;
    hash.bhp256 r88 into r89 as field;
    get.or_use balances[r89] 0u128 into r90;
    add r90 1000u128 into r91;
    set r91 into balances[r89];

function add_liquidity:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.public;
    lt r0 r1 into r7;
    assert.eq r7 true ;
    gt r2 0u128 into r8;
    gte r2 r4 into r9;
    and r8 r9 into r10;
    assert.eq r10 true ;
    gt r3 0u128 into r11;
    gte r3 r5 into r12;
    and r11 r12 into r13;
    assert.eq r13 true ;
    async add_liquidity self.caller r0 r1 r2 r3 r4 r5 r6 into r14;
    output r14 as testalphav1x1.aleo/add_liquidity.future;

finalize add_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as u128.public;
    input r7 as address.public;
    lt r1 r2 into r8;
    assert.eq r8 true ;
    cast r1 r2 into r9 as PairKeyData;
    hash.bhp256 r9 into r10 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r10 into r11 as TokenIdData;
    hash.bhp256 r11 into r12 as field;
    get pairs[r12] into r13;
    get tokens[r12] into r14;
    get global_state[true] into r15;
    is.eq r15.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r16;
    mul r13.reserve_a r13.reserve_b into r17;
    is.eq r17 0u128 into r18;
    is.eq r17 0u128 into r19;
    ternary r19 1u128 r17 into r20;
    shr r20 64u32 into r21;
    gt r21 0u128 into r22;
    shr r20 64u32 into r23;
    add 0u32 64u32 into r24;
    ternary r22 r23 r20 into r25;
    ternary r22 r24 0u32 into r26;
    shr r25 32u32 into r27;
    gt r27 0u128 into r28;
    shr r25 32u32 into r29;
    add r26 32u32 into r30;
    ternary r28 r29 r25 into r31;
    ternary r28 r30 r26 into r32;
    shr r31 16u32 into r33;
    gt r33 0u128 into r34;
    shr r31 16u32 into r35;
    add r32 16u32 into r36;
    ternary r34 r35 r31 into r37;
    ternary r34 r36 r32 into r38;
    shr r37 8u32 into r39;
    gt r39 0u128 into r40;
    shr r37 8u32 into r41;
    add r38 8u32 into r42;
    ternary r40 r41 r37 into r43;
    ternary r40 r42 r38 into r44;
    shr r43 4u32 into r45;
    gt r45 0u128 into r46;
    shr r43 4u32 into r47;
    add r44 4u32 into r48;
    ternary r46 r47 r43 into r49;
    ternary r46 r48 r44 into r50;
    shr r49 2u32 into r51;
    gt r51 0u128 into r52;
    shr r49 2u32 into r53;
    add r50 2u32 into r54;
    ternary r52 r53 r49 into r55;
    ternary r52 r54 r50 into r56;
    shr r55 1u32 into r57;
    gt r57 0u128 into r58;
    add r56 1u32 into r59;
    ternary r58 r59 r56 into r60;
    div r60 2u32 into r61;
    shl 1u128 r61 into r62;
    div r20 r62 into r63;
    add r62 r63 into r64;
    shr r64 1u32 into r65;
    div r20 r65 into r66;
    add r65 r66 into r67;
    shr r67 1u32 into r68;
    div r20 r68 into r69;
    add r68 r69 into r70;
    shr r70 1u32 into r71;
    div r20 r71 into r72;
    add r71 r72 into r73;
    shr r73 1u32 into r74;
    div r20 r74 into r75;
    add r74 r75 into r76;
    shr r76 1u32 into r77;
    div r20 r77 into r78;
    add r77 r78 into r79;
    shr r79 1u32 into r80;
    div r20 r80 into r81;
    add r80 r81 into r82;
    shr r82 1u32 into r83;
    div r20 r83 into r84;
    lt r83 r84 into r85;
    ternary r85 r83 r84 into r86;
    ternary r18 0u128 r86 into r87;
    ternary r16 0u128 r87 into r88;
    is.eq r13.last_k 0u128 into r89;
    is.eq r13.last_k 0u128 into r90;
    ternary r90 1u128 r13.last_k into r91;
    shr r91 64u32 into r92;
    gt r92 0u128 into r93;
    shr r91 64u32 into r94;
    add 0u32 64u32 into r95;
    ternary r93 r94 r91 into r96;
    ternary r93 r95 0u32 into r97;
    shr r96 32u32 into r98;
    gt r98 0u128 into r99;
    shr r96 32u32 into r100;
    add r97 32u32 into r101;
    ternary r99 r100 r96 into r102;
    ternary r99 r101 r97 into r103;
    shr r102 16u32 into r104;
    gt r104 0u128 into r105;
    shr r102 16u32 into r106;
    add r103 16u32 into r107;
    ternary r105 r106 r102 into r108;
    ternary r105 r107 r103 into r109;
    shr r108 8u32 into r110;
    gt r110 0u128 into r111;
    shr r108 8u32 into r112;
    add r109 8u32 into r113;
    ternary r111 r112 r108 into r114;
    ternary r111 r113 r109 into r115;
    shr r114 4u32 into r116;
    gt r116 0u128 into r117;
    shr r114 4u32 into r118;
    add r115 4u32 into r119;
    ternary r117 r118 r114 into r120;
    ternary r117 r119 r115 into r121;
    shr r120 2u32 into r122;
    gt r122 0u128 into r123;
    shr r120 2u32 into r124;
    add r121 2u32 into r125;
    ternary r123 r124 r120 into r126;
    ternary r123 r125 r121 into r127;
    shr r126 1u32 into r128;
    gt r128 0u128 into r129;
    add r127 1u32 into r130;
    ternary r129 r130 r127 into r131;
    div r131 2u32 into r132;
    shl 1u128 r132 into r133;
    div r91 r133 into r134;
    add r133 r134 into r135;
    shr r135 1u32 into r136;
    div r91 r136 into r137;
    add r136 r137 into r138;
    shr r138 1u32 into r139;
    div r91 r139 into r140;
    add r139 r140 into r141;
    shr r141 1u32 into r142;
    div r91 r142 into r143;
    add r142 r143 into r144;
    shr r144 1u32 into r145;
    div r91 r145 into r146;
    add r145 r146 into r147;
    shr r147 1u32 into r148;
    div r91 r148 into r149;
    add r148 r149 into r150;
    shr r150 1u32 into r151;
    div r91 r151 into r152;
    add r151 r152 into r153;
    shr r153 1u32 into r154;
    div r91 r154 into r155;
    lt r154 r155 into r156;
    ternary r156 r154 r155 into r157;
    ternary r89 0u128 r157 into r158;
    mul r88 5u128 into r159;
    add r159 r158 into r160;
    is.eq r160 0u128 into r161;
    ternary r161 1u128 r160 into r162;
    is.eq r13.last_k 0u128 into r163;
    lte r88 r158 into r164;
    or r163 r164 into r165;
    sub.w r88 r158 into r166;
    mul.w r14.total_supply r166 into r167;
    div r167 r162 into r168;
    ternary r165 0u128 r168 into r169;
    cast r12 r15.fee_to into r170 as BalanceKeyData;
    hash.bhp256 r170 into r171 as field;
    get.or_use balances[r171] 0u128 into r172;
    add r172 r169 into r173;
    set r173 into balances[r171];
    add r14.total_supply r169 into r174;
    mul r3 r174 into r175;
    div r175 r13.reserve_a into r176;
    mul r4 r174 into r177;
    div r177 r13.reserve_b into r178;
    lte r176 r178 into r179;
    ternary r179 r176 r178 into r180;
    lte r176 r180 into r181;
    mul r180 r13.reserve_a into r182;
    add r182 r174 into r183;
    sub r183 1u128 into r184;
    div r184 r174 into r185;
    ternary r181 r3 r185 into r186;
    lte r178 r180 into r187;
    mul r180 r13.reserve_b into r188;
    add r188 r174 into r189;
    sub r189 1u128 into r190;
    div r190 r174 into r191;
    ternary r187 r4 r191 into r192;
    gt r180 0u128 into r193;
    assert.eq r193 true ;
    gte r186 r5 into r194;
    assert.eq r194 true ;
    gte r192 r6 into r195;
    assert.eq r195 true ;
    cast r1 r0 into r196 as BalanceKeyData;
    hash.bhp256 r196 into r197 as field;
    get balances[r197] into r198;
    sub r198 r186 into r199;
    set r199 into balances[r197];
    cast r2 r0 into r200 as BalanceKeyData;
    hash.bhp256 r200 into r201 as field;
    get balances[r201] into r202;
    sub r202 r192 into r203;
    set r203 into balances[r201];
    cast r12 r7 into r204 as BalanceKeyData;
    hash.bhp256 r204 into r205 as field;
    get.or_use balances[r205] 0u128 into r206;
    add r206 r180 into r207;
    set r207 into balances[r205];
    add r174 r180 into r208;
    cast r14.name r14.symbol r14.decimals r208 r14.admin r14.mintable r14.burnable into r209 as TokenInfo;
    set r209 into tokens[r12];
    add r13.reserve_a r186 into r210;
    add r13.reserve_b r192 into r211;
    is.eq r15.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r212;
    mul r210 r211 into r213;
    ternary r212 0u128 r213 into r214;
    cast r210 r211 r214 into r215 as Pair;
    set r215 into pairs[r12];

function add_liquidity_privately:
    input r0 as PrivateToken.record;
    input r1 as PrivateToken.record;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as u128.public;
    input r7 as address.private;
    input r8 as address.public;
    lt r0.token r1.token into r9;
    assert.eq r9 true ;
    gt r2 0u128 into r10;
    gte r2 r4 into r11;
    and r10 r11 into r12;
    assert.eq r12 true ;
    gt r3 0u128 into r13;
    gte r3 r5 into r14;
    and r13 r14 into r15;
    assert.eq r15 true ;
    gt r6 0u128 into r16;
    assert.eq r16 true ;
    sub r0.amount r2 into r17;
    cast r0.owner r0.token r17 into r18 as PrivateToken.record;
    sub r1.amount r3 into r19;
    cast r1.owner r1.token r19 into r20 as PrivateToken.record;
    lt r0.token r1.token into r21;
    assert.eq r21 true ;
    cast r0.token r1.token into r22 as PairKeyData;
    hash.bhp256 r22 into r23 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r23 into r24 as TokenIdData;
    hash.bhp256 r24 into r25 as field;
    cast r7 r25 r6 into r26 as PrivateToken.record;
    async add_liquidity_privately r0.token r1.token r25 r2 r3 r4 r5 r6 r8 into r27;
    output r26 as PrivateToken.record;
    output r18 as PrivateToken.record;
    output r20 as PrivateToken.record;
    output r27 as testalphav1x1.aleo/add_liquidity_privately.future;

finalize add_liquidity_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as u128.public;
    input r7 as u128.public;
    input r8 as address.public;
    get pairs[r2] into r9;
    get tokens[r2] into r10;
    get global_state[true] into r11;
    is.eq r11.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r12;
    mul r9.reserve_a r9.reserve_b into r13;
    is.eq r13 0u128 into r14;
    is.eq r13 0u128 into r15;
    ternary r15 1u128 r13 into r16;
    shr r16 64u32 into r17;
    gt r17 0u128 into r18;
    shr r16 64u32 into r19;
    add 0u32 64u32 into r20;
    ternary r18 r19 r16 into r21;
    ternary r18 r20 0u32 into r22;
    shr r21 32u32 into r23;
    gt r23 0u128 into r24;
    shr r21 32u32 into r25;
    add r22 32u32 into r26;
    ternary r24 r25 r21 into r27;
    ternary r24 r26 r22 into r28;
    shr r27 16u32 into r29;
    gt r29 0u128 into r30;
    shr r27 16u32 into r31;
    add r28 16u32 into r32;
    ternary r30 r31 r27 into r33;
    ternary r30 r32 r28 into r34;
    shr r33 8u32 into r35;
    gt r35 0u128 into r36;
    shr r33 8u32 into r37;
    add r34 8u32 into r38;
    ternary r36 r37 r33 into r39;
    ternary r36 r38 r34 into r40;
    shr r39 4u32 into r41;
    gt r41 0u128 into r42;
    shr r39 4u32 into r43;
    add r40 4u32 into r44;
    ternary r42 r43 r39 into r45;
    ternary r42 r44 r40 into r46;
    shr r45 2u32 into r47;
    gt r47 0u128 into r48;
    shr r45 2u32 into r49;
    add r46 2u32 into r50;
    ternary r48 r49 r45 into r51;
    ternary r48 r50 r46 into r52;
    shr r51 1u32 into r53;
    gt r53 0u128 into r54;
    add r52 1u32 into r55;
    ternary r54 r55 r52 into r56;
    div r56 2u32 into r57;
    shl 1u128 r57 into r58;
    div r16 r58 into r59;
    add r58 r59 into r60;
    shr r60 1u32 into r61;
    div r16 r61 into r62;
    add r61 r62 into r63;
    shr r63 1u32 into r64;
    div r16 r64 into r65;
    add r64 r65 into r66;
    shr r66 1u32 into r67;
    div r16 r67 into r68;
    add r67 r68 into r69;
    shr r69 1u32 into r70;
    div r16 r70 into r71;
    add r70 r71 into r72;
    shr r72 1u32 into r73;
    div r16 r73 into r74;
    add r73 r74 into r75;
    shr r75 1u32 into r76;
    div r16 r76 into r77;
    add r76 r77 into r78;
    shr r78 1u32 into r79;
    div r16 r79 into r80;
    lt r79 r80 into r81;
    ternary r81 r79 r80 into r82;
    ternary r14 0u128 r82 into r83;
    ternary r12 0u128 r83 into r84;
    is.eq r9.last_k 0u128 into r85;
    is.eq r9.last_k 0u128 into r86;
    ternary r86 1u128 r9.last_k into r87;
    shr r87 64u32 into r88;
    gt r88 0u128 into r89;
    shr r87 64u32 into r90;
    add 0u32 64u32 into r91;
    ternary r89 r90 r87 into r92;
    ternary r89 r91 0u32 into r93;
    shr r92 32u32 into r94;
    gt r94 0u128 into r95;
    shr r92 32u32 into r96;
    add r93 32u32 into r97;
    ternary r95 r96 r92 into r98;
    ternary r95 r97 r93 into r99;
    shr r98 16u32 into r100;
    gt r100 0u128 into r101;
    shr r98 16u32 into r102;
    add r99 16u32 into r103;
    ternary r101 r102 r98 into r104;
    ternary r101 r103 r99 into r105;
    shr r104 8u32 into r106;
    gt r106 0u128 into r107;
    shr r104 8u32 into r108;
    add r105 8u32 into r109;
    ternary r107 r108 r104 into r110;
    ternary r107 r109 r105 into r111;
    shr r110 4u32 into r112;
    gt r112 0u128 into r113;
    shr r110 4u32 into r114;
    add r111 4u32 into r115;
    ternary r113 r114 r110 into r116;
    ternary r113 r115 r111 into r117;
    shr r116 2u32 into r118;
    gt r118 0u128 into r119;
    shr r116 2u32 into r120;
    add r117 2u32 into r121;
    ternary r119 r120 r116 into r122;
    ternary r119 r121 r117 into r123;
    shr r122 1u32 into r124;
    gt r124 0u128 into r125;
    add r123 1u32 into r126;
    ternary r125 r126 r123 into r127;
    div r127 2u32 into r128;
    shl 1u128 r128 into r129;
    div r87 r129 into r130;
    add r129 r130 into r131;
    shr r131 1u32 into r132;
    div r87 r132 into r133;
    add r132 r133 into r134;
    shr r134 1u32 into r135;
    div r87 r135 into r136;
    add r135 r136 into r137;
    shr r137 1u32 into r138;
    div r87 r138 into r139;
    add r138 r139 into r140;
    shr r140 1u32 into r141;
    div r87 r141 into r142;
    add r141 r142 into r143;
    shr r143 1u32 into r144;
    div r87 r144 into r145;
    add r144 r145 into r146;
    shr r146 1u32 into r147;
    div r87 r147 into r148;
    add r147 r148 into r149;
    shr r149 1u32 into r150;
    div r87 r150 into r151;
    lt r150 r151 into r152;
    ternary r152 r150 r151 into r153;
    ternary r85 0u128 r153 into r154;
    mul r84 5u128 into r155;
    add r155 r154 into r156;
    is.eq r156 0u128 into r157;
    ternary r157 1u128 r156 into r158;
    is.eq r9.last_k 0u128 into r159;
    lte r84 r154 into r160;
    or r159 r160 into r161;
    sub.w r84 r154 into r162;
    mul.w r10.total_supply r162 into r163;
    div r163 r158 into r164;
    ternary r161 0u128 r164 into r165;
    cast r2 r11.fee_to into r166 as BalanceKeyData;
    hash.bhp256 r166 into r167 as field;
    get.or_use balances[r167] 0u128 into r168;
    add r168 r165 into r169;
    set r169 into balances[r167];
    add r10.total_supply r165 into r170;
    mul r3 r170 into r171;
    div r171 r9.reserve_a into r172;
    mul r4 r170 into r173;
    div r173 r9.reserve_b into r174;
    lte r172 r174 into r175;
    ternary r175 r172 r174 into r176;
    lte r172 r176 into r177;
    mul r176 r9.reserve_a into r178;
    add r178 r170 into r179;
    sub r179 1u128 into r180;
    div r180 r170 into r181;
    ternary r177 r3 r181 into r182;
    lte r174 r176 into r183;
    mul r176 r9.reserve_b into r184;
    add r184 r170 into r185;
    sub r185 1u128 into r186;
    div r186 r170 into r187;
    ternary r183 r4 r187 into r188;
    gte r176 r7 into r189;
    assert.eq r189 true ;
    gte r3 r182 into r190;
    gte r182 r5 into r191;
    and r190 r191 into r192;
    assert.eq r192 true ;
    gte r4 r188 into r193;
    gte r188 r6 into r194;
    and r193 r194 into r195;
    assert.eq r195 true ;
    cast r0 r8 into r196 as BalanceKeyData;
    hash.bhp256 r196 into r197 as field;
    get.or_use balances[r197] 0u128 into r198;
    add r198 r3 into r199;
    sub r199 r182 into r200;
    set r200 into balances[r197];
    cast r1 r8 into r201 as BalanceKeyData;
    hash.bhp256 r201 into r202 as field;
    get.or_use balances[r202] 0u128 into r203;
    add r203 r4 into r204;
    sub r204 r188 into r205;
    set r205 into balances[r202];
    cast r2 r8 into r206 as BalanceKeyData;
    hash.bhp256 r206 into r207 as field;
    get.or_use balances[r207] 0u128 into r208;
    add r208 r176 into r209;
    sub r209 r7 into r210;
    set r210 into balances[r207];
    add r170 r176 into r211;
    cast r10.name r10.symbol r10.decimals r211 r10.admin r10.mintable r10.burnable into r212 as TokenInfo;
    set r212 into tokens[r2];
    add r9.reserve_a r182 into r213;
    add r9.reserve_b r188 into r214;
    is.eq r11.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r215;
    mul r213 r214 into r216;
    ternary r215 0u128 r216 into r217;
    cast r213 r214 r217 into r218 as Pair;
    set r218 into pairs[r2];

function remove_liquidity:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r0 r1 into r6;
    assert.eq r6 true ;
    gt r2 0u128 into r7;
    assert.eq r7 true ;
    async remove_liquidity self.caller r0 r1 r2 r3 r4 r5 into r8;
    output r8 as testalphav1x1.aleo/remove_liquidity.future;

finalize remove_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.public;
    lt r1 r2 into r7;
    assert.eq r7 true ;
    cast r1 r2 into r8 as PairKeyData;
    hash.bhp256 r8 into r9 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r9 into r10 as TokenIdData;
    hash.bhp256 r10 into r11 as field;
    get tokens[r11] into r12;
    get pairs[r11] into r13;
    get global_state[true] into r14;
    is.eq r14.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r15;
    mul r13.reserve_a r13.reserve_b into r16;
    is.eq r16 0u128 into r17;
    is.eq r16 0u128 into r18;
    ternary r18 1u128 r16 into r19;
    shr r19 64u32 into r20;
    gt r20 0u128 into r21;
    shr r19 64u32 into r22;
    add 0u32 64u32 into r23;
    ternary r21 r22 r19 into r24;
    ternary r21 r23 0u32 into r25;
    shr r24 32u32 into r26;
    gt r26 0u128 into r27;
    shr r24 32u32 into r28;
    add r25 32u32 into r29;
    ternary r27 r28 r24 into r30;
    ternary r27 r29 r25 into r31;
    shr r30 16u32 into r32;
    gt r32 0u128 into r33;
    shr r30 16u32 into r34;
    add r31 16u32 into r35;
    ternary r33 r34 r30 into r36;
    ternary r33 r35 r31 into r37;
    shr r36 8u32 into r38;
    gt r38 0u128 into r39;
    shr r36 8u32 into r40;
    add r37 8u32 into r41;
    ternary r39 r40 r36 into r42;
    ternary r39 r41 r37 into r43;
    shr r42 4u32 into r44;
    gt r44 0u128 into r45;
    shr r42 4u32 into r46;
    add r43 4u32 into r47;
    ternary r45 r46 r42 into r48;
    ternary r45 r47 r43 into r49;
    shr r48 2u32 into r50;
    gt r50 0u128 into r51;
    shr r48 2u32 into r52;
    add r49 2u32 into r53;
    ternary r51 r52 r48 into r54;
    ternary r51 r53 r49 into r55;
    shr r54 1u32 into r56;
    gt r56 0u128 into r57;
    add r55 1u32 into r58;
    ternary r57 r58 r55 into r59;
    div r59 2u32 into r60;
    shl 1u128 r60 into r61;
    div r19 r61 into r62;
    add r61 r62 into r63;
    shr r63 1u32 into r64;
    div r19 r64 into r65;
    add r64 r65 into r66;
    shr r66 1u32 into r67;
    div r19 r67 into r68;
    add r67 r68 into r69;
    shr r69 1u32 into r70;
    div r19 r70 into r71;
    add r70 r71 into r72;
    shr r72 1u32 into r73;
    div r19 r73 into r74;
    add r73 r74 into r75;
    shr r75 1u32 into r76;
    div r19 r76 into r77;
    add r76 r77 into r78;
    shr r78 1u32 into r79;
    div r19 r79 into r80;
    add r79 r80 into r81;
    shr r81 1u32 into r82;
    div r19 r82 into r83;
    lt r82 r83 into r84;
    ternary r84 r82 r83 into r85;
    ternary r17 0u128 r85 into r86;
    ternary r15 0u128 r86 into r87;
    is.eq r13.last_k 0u128 into r88;
    is.eq r13.last_k 0u128 into r89;
    ternary r89 1u128 r13.last_k into r90;
    shr r90 64u32 into r91;
    gt r91 0u128 into r92;
    shr r90 64u32 into r93;
    add 0u32 64u32 into r94;
    ternary r92 r93 r90 into r95;
    ternary r92 r94 0u32 into r96;
    shr r95 32u32 into r97;
    gt r97 0u128 into r98;
    shr r95 32u32 into r99;
    add r96 32u32 into r100;
    ternary r98 r99 r95 into r101;
    ternary r98 r100 r96 into r102;
    shr r101 16u32 into r103;
    gt r103 0u128 into r104;
    shr r101 16u32 into r105;
    add r102 16u32 into r106;
    ternary r104 r105 r101 into r107;
    ternary r104 r106 r102 into r108;
    shr r107 8u32 into r109;
    gt r109 0u128 into r110;
    shr r107 8u32 into r111;
    add r108 8u32 into r112;
    ternary r110 r111 r107 into r113;
    ternary r110 r112 r108 into r114;
    shr r113 4u32 into r115;
    gt r115 0u128 into r116;
    shr r113 4u32 into r117;
    add r114 4u32 into r118;
    ternary r116 r117 r113 into r119;
    ternary r116 r118 r114 into r120;
    shr r119 2u32 into r121;
    gt r121 0u128 into r122;
    shr r119 2u32 into r123;
    add r120 2u32 into r124;
    ternary r122 r123 r119 into r125;
    ternary r122 r124 r120 into r126;
    shr r125 1u32 into r127;
    gt r127 0u128 into r128;
    add r126 1u32 into r129;
    ternary r128 r129 r126 into r130;
    div r130 2u32 into r131;
    shl 1u128 r131 into r132;
    div r90 r132 into r133;
    add r132 r133 into r134;
    shr r134 1u32 into r135;
    div r90 r135 into r136;
    add r135 r136 into r137;
    shr r137 1u32 into r138;
    div r90 r138 into r139;
    add r138 r139 into r140;
    shr r140 1u32 into r141;
    div r90 r141 into r142;
    add r141 r142 into r143;
    shr r143 1u32 into r144;
    div r90 r144 into r145;
    add r144 r145 into r146;
    shr r146 1u32 into r147;
    div r90 r147 into r148;
    add r147 r148 into r149;
    shr r149 1u32 into r150;
    div r90 r150 into r151;
    add r150 r151 into r152;
    shr r152 1u32 into r153;
    div r90 r153 into r154;
    lt r153 r154 into r155;
    ternary r155 r153 r154 into r156;
    ternary r88 0u128 r156 into r157;
    mul r87 5u128 into r158;
    add r158 r157 into r159;
    is.eq r159 0u128 into r160;
    ternary r160 1u128 r159 into r161;
    is.eq r13.last_k 0u128 into r162;
    lte r87 r157 into r163;
    or r162 r163 into r164;
    sub.w r87 r157 into r165;
    mul.w r12.total_supply r165 into r166;
    div r166 r161 into r167;
    ternary r164 0u128 r167 into r168;
    cast r11 r14.fee_to into r169 as BalanceKeyData;
    hash.bhp256 r169 into r170 as field;
    get.or_use balances[r170] 0u128 into r171;
    add r171 r168 into r172;
    set r172 into balances[r170];
    add r12.total_supply r168 into r173;
    mul r3 r13.reserve_a into r174;
    div r174 r173 into r175;
    mul r3 r13.reserve_b into r176;
    div r176 r173 into r177;
    gte r175 r4 into r178;
    gte r177 r5 into r179;
    and r178 r179 into r180;
    assert.eq r180 true ;
    gt r175 0u128 into r181;
    gt r177 0u128 into r182;
    or r181 r182 into r183;
    assert.eq r183 true ;
    cast r11 r0 into r184 as BalanceKeyData;
    hash.bhp256 r184 into r185 as field;
    get balances[r185] into r186;
    sub r186 r3 into r187;
    set r187 into balances[r185];
    sub r173 r3 into r188;
    cast r12.name r12.symbol r12.decimals r188 r12.admin r12.mintable r12.burnable into r189 as TokenInfo;
    set r189 into tokens[r11];
    sub r13.reserve_a r175 into r190;
    sub r13.reserve_b r177 into r191;
    sub r13.reserve_a r175 into r192;
    sub r13.reserve_b r177 into r193;
    is.eq r14.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r194;
    mul r190 r191 into r195;
    ternary r194 0u128 r195 into r196;
    cast r192 r193 r196 into r197 as Pair;
    set r197 into pairs[r11];
    cast r1 r6 into r198 as BalanceKeyData;
    hash.bhp256 r198 into r199 as field;
    cast r2 r6 into r200 as BalanceKeyData;
    hash.bhp256 r200 into r201 as field;
    get.or_use balances[r199] 0u128 into r202;
    add r202 r175 into r203;
    set r203 into balances[r199];
    get.or_use balances[r201] 0u128 into r204;
    add r204 r177 into r205;
    set r205 into balances[r201];

function remove_liquidity_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as PrivateToken.record;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.private;
    input r7 as address.public;
    lt r0 r1 into r8;
    assert.eq r8 true ;
    gt r3 0u128 into r9;
    assert.eq r9 true ;
    lt r0 r1 into r10;
    assert.eq r10 true ;
    cast r0 r1 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r12 into r13 as TokenIdData;
    hash.bhp256 r13 into r14 as field;
    assert.eq r14 r2.token ;
    cast r6 r0 r4 into r15 as PrivateToken.record;
    cast r6 r1 r5 into r16 as PrivateToken.record;
    sub r2.amount r3 into r17;
    cast r2.owner r14 r17 into r18 as PrivateToken.record;
    async remove_liquidity_privately r0 r1 r14 r3 r4 r5 r7 into r19;
    output r15 as PrivateToken.record;
    output r16 as PrivateToken.record;
    output r18 as PrivateToken.record;
    output r19 as testalphav1x1.aleo/remove_liquidity_privately.future;

finalize remove_liquidity_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.public;
    get pairs[r2] into r7;
    get tokens[r2] into r8;
    get global_state[true] into r9;
    is.eq r9.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r10;
    mul r7.reserve_a r7.reserve_b into r11;
    is.eq r11 0u128 into r12;
    is.eq r11 0u128 into r13;
    ternary r13 1u128 r11 into r14;
    shr r14 64u32 into r15;
    gt r15 0u128 into r16;
    shr r14 64u32 into r17;
    add 0u32 64u32 into r18;
    ternary r16 r17 r14 into r19;
    ternary r16 r18 0u32 into r20;
    shr r19 32u32 into r21;
    gt r21 0u128 into r22;
    shr r19 32u32 into r23;
    add r20 32u32 into r24;
    ternary r22 r23 r19 into r25;
    ternary r22 r24 r20 into r26;
    shr r25 16u32 into r27;
    gt r27 0u128 into r28;
    shr r25 16u32 into r29;
    add r26 16u32 into r30;
    ternary r28 r29 r25 into r31;
    ternary r28 r30 r26 into r32;
    shr r31 8u32 into r33;
    gt r33 0u128 into r34;
    shr r31 8u32 into r35;
    add r32 8u32 into r36;
    ternary r34 r35 r31 into r37;
    ternary r34 r36 r32 into r38;
    shr r37 4u32 into r39;
    gt r39 0u128 into r40;
    shr r37 4u32 into r41;
    add r38 4u32 into r42;
    ternary r40 r41 r37 into r43;
    ternary r40 r42 r38 into r44;
    shr r43 2u32 into r45;
    gt r45 0u128 into r46;
    shr r43 2u32 into r47;
    add r44 2u32 into r48;
    ternary r46 r47 r43 into r49;
    ternary r46 r48 r44 into r50;
    shr r49 1u32 into r51;
    gt r51 0u128 into r52;
    add r50 1u32 into r53;
    ternary r52 r53 r50 into r54;
    div r54 2u32 into r55;
    shl 1u128 r55 into r56;
    div r14 r56 into r57;
    add r56 r57 into r58;
    shr r58 1u32 into r59;
    div r14 r59 into r60;
    add r59 r60 into r61;
    shr r61 1u32 into r62;
    div r14 r62 into r63;
    add r62 r63 into r64;
    shr r64 1u32 into r65;
    div r14 r65 into r66;
    add r65 r66 into r67;
    shr r67 1u32 into r68;
    div r14 r68 into r69;
    add r68 r69 into r70;
    shr r70 1u32 into r71;
    div r14 r71 into r72;
    add r71 r72 into r73;
    shr r73 1u32 into r74;
    div r14 r74 into r75;
    add r74 r75 into r76;
    shr r76 1u32 into r77;
    div r14 r77 into r78;
    lt r77 r78 into r79;
    ternary r79 r77 r78 into r80;
    ternary r12 0u128 r80 into r81;
    ternary r10 0u128 r81 into r82;
    is.eq r7.last_k 0u128 into r83;
    is.eq r7.last_k 0u128 into r84;
    ternary r84 1u128 r7.last_k into r85;
    shr r85 64u32 into r86;
    gt r86 0u128 into r87;
    shr r85 64u32 into r88;
    add 0u32 64u32 into r89;
    ternary r87 r88 r85 into r90;
    ternary r87 r89 0u32 into r91;
    shr r90 32u32 into r92;
    gt r92 0u128 into r93;
    shr r90 32u32 into r94;
    add r91 32u32 into r95;
    ternary r93 r94 r90 into r96;
    ternary r93 r95 r91 into r97;
    shr r96 16u32 into r98;
    gt r98 0u128 into r99;
    shr r96 16u32 into r100;
    add r97 16u32 into r101;
    ternary r99 r100 r96 into r102;
    ternary r99 r101 r97 into r103;
    shr r102 8u32 into r104;
    gt r104 0u128 into r105;
    shr r102 8u32 into r106;
    add r103 8u32 into r107;
    ternary r105 r106 r102 into r108;
    ternary r105 r107 r103 into r109;
    shr r108 4u32 into r110;
    gt r110 0u128 into r111;
    shr r108 4u32 into r112;
    add r109 4u32 into r113;
    ternary r111 r112 r108 into r114;
    ternary r111 r113 r109 into r115;
    shr r114 2u32 into r116;
    gt r116 0u128 into r117;
    shr r114 2u32 into r118;
    add r115 2u32 into r119;
    ternary r117 r118 r114 into r120;
    ternary r117 r119 r115 into r121;
    shr r120 1u32 into r122;
    gt r122 0u128 into r123;
    add r121 1u32 into r124;
    ternary r123 r124 r121 into r125;
    div r125 2u32 into r126;
    shl 1u128 r126 into r127;
    div r85 r127 into r128;
    add r127 r128 into r129;
    shr r129 1u32 into r130;
    div r85 r130 into r131;
    add r130 r131 into r132;
    shr r132 1u32 into r133;
    div r85 r133 into r134;
    add r133 r134 into r135;
    shr r135 1u32 into r136;
    div r85 r136 into r137;
    add r136 r137 into r138;
    shr r138 1u32 into r139;
    div r85 r139 into r140;
    add r139 r140 into r141;
    shr r141 1u32 into r142;
    div r85 r142 into r143;
    add r142 r143 into r144;
    shr r144 1u32 into r145;
    div r85 r145 into r146;
    add r145 r146 into r147;
    shr r147 1u32 into r148;
    div r85 r148 into r149;
    lt r148 r149 into r150;
    ternary r150 r148 r149 into r151;
    ternary r83 0u128 r151 into r152;
    mul r82 5u128 into r153;
    add r153 r152 into r154;
    is.eq r154 0u128 into r155;
    ternary r155 1u128 r154 into r156;
    is.eq r7.last_k 0u128 into r157;
    lte r82 r152 into r158;
    or r157 r158 into r159;
    sub.w r82 r152 into r160;
    mul.w r8.total_supply r160 into r161;
    div r161 r156 into r162;
    ternary r159 0u128 r162 into r163;
    cast r2 r9.fee_to into r164 as BalanceKeyData;
    hash.bhp256 r164 into r165 as field;
    get.or_use balances[r165] 0u128 into r166;
    add r166 r163 into r167;
    set r167 into balances[r165];
    add r8.total_supply r163 into r168;
    mul r3 r7.reserve_a into r169;
    div r169 r168 into r170;
    mul r3 r7.reserve_b into r171;
    div r171 r168 into r172;
    gte r170 r4 into r173;
    gte r172 r5 into r174;
    and r173 r174 into r175;
    assert.eq r175 true ;
    gt r170 0u128 into r176;
    gt r172 0u128 into r177;
    or r176 r177 into r178;
    assert.eq r178 true ;
    sub r168 r3 into r179;
    cast r8.name r8.symbol r8.decimals r179 r8.admin r8.mintable r8.burnable into r180 as TokenInfo;
    set r180 into tokens[r2];
    sub r7.reserve_a r170 into r181;
    sub r7.reserve_b r172 into r182;
    sub r7.reserve_a r170 into r183;
    sub r7.reserve_b r172 into r184;
    is.eq r9.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r185;
    mul r181 r182 into r186;
    ternary r185 0u128 r186 into r187;
    cast r183 r184 r187 into r188 as Pair;
    set r188 into pairs[r2];
    cast r0 r6 into r189 as BalanceKeyData;
    hash.bhp256 r189 into r190 as field;
    cast r1 r6 into r191 as BalanceKeyData;
    hash.bhp256 r191 into r192 as field;
    get.or_use balances[r190] 0u128 into r193;
    add r193 r170 into r194;
    sub r194 r4 into r195;
    set r195 into balances[r190];
    get.or_use balances[r192] 0u128 into r196;
    add r196 r172 into r197;
    sub r197 r5 into r198;
    set r198 into balances[r192];

function swap_exact_tokens_for_tokens:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0 r1 into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    async swap_exact_tokens_for_tokens self.caller r0 r1 r2 r3 r4 into r7;
    output r7 as testalphav1x1.aleo/swap_exact_tokens_for_tokens.future;

finalize swap_exact_tokens_for_tokens:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r1 r2 into r6;
    ternary r6 r1 r2 into r7;
    lt r1 r2 into r8;
    ternary r8 r2 r1 into r9;
    lt r7 r9 into r10;
    assert.eq r10 true ;
    cast r7 r9 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r12 into r13 as TokenIdData;
    hash.bhp256 r13 into r14 as field;
    get pairs[r14] into r15;
    is.eq r7 r1 into r16;
    ternary r16 r15.reserve_a r15.reserve_b into r17;
    is.eq r7 r2 into r18;
    ternary r18 r15.reserve_a r15.reserve_b into r19;
    mul r3 997u128 into r20;
    mul r20 r19 into r21;
    mul r17 1000u128 into r22;
    add r22 r20 into r23;
    div r21 r23 into r24;
    gte r24 r4 into r25;
    assert.eq r25 true ;
    gt r24 0u128 into r26;
    assert.eq r26 true ;
    cast r1 r0 into r27 as BalanceKeyData;
    hash.bhp256 r27 into r28 as field;
    get balances[r28] into r29;
    sub r29 r3 into r30;
    set r30 into balances[r28];
    add r17 r3 into r31;
    sub r19 r24 into r32;
    is.eq r7 r1 into r33;
    ternary r33 r31 r32 into r34;
    is.eq r9 r1 into r35;
    ternary r35 r31 r32 into r36;
    cast r34 r36 r15.last_k into r37 as Pair;
    set r37 into pairs[r14];
    cast r2 r5 into r38 as BalanceKeyData;
    hash.bhp256 r38 into r39 as field;
    get.or_use balances[r39] 0u128 into r40;
    add r40 r24 into r41;
    set r41 into balances[r39];

function swap_exact_private_for_public:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0.token r1 into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    sub r0.amount r2 into r7;
    cast r0.owner r0.token r7 into r8 as PrivateToken.record;
    async swap_exact_private_for_public r0.token r1 r2 r3 r4 into r9;
    output r8 as PrivateToken.record;
    output r9 as testalphav1x1.aleo/swap_exact_private_for_public.future;

finalize swap_exact_private_for_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    ternary r5 r0 r1 into r6;
    lt r0 r1 into r7;
    ternary r7 r1 r0 into r8;
    lt r6 r8 into r9;
    assert.eq r9 true ;
    cast r6 r8 into r10 as PairKeyData;
    hash.bhp256 r10 into r11 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r11 into r12 as TokenIdData;
    hash.bhp256 r12 into r13 as field;
    get pairs[r13] into r14;
    is.eq r6 r0 into r15;
    ternary r15 r14.reserve_a r14.reserve_b into r16;
    is.eq r6 r1 into r17;
    ternary r17 r14.reserve_a r14.reserve_b into r18;
    mul r2 997u128 into r19;
    mul r19 r18 into r20;
    mul r16 1000u128 into r21;
    add r21 r19 into r22;
    div r20 r22 into r23;
    gte r23 r3 into r24;
    assert.eq r24 true ;
    gt r23 0u128 into r25;
    assert.eq r25 true ;
    add r16 r2 into r26;
    sub r18 r23 into r27;
    is.eq r6 r0 into r28;
    ternary r28 r26 r27 into r29;
    is.eq r8 r0 into r30;
    ternary r30 r26 r27 into r31;
    cast r29 r31 r14.last_k into r32 as Pair;
    set r32 into pairs[r13];
    cast r1 r4 into r33 as BalanceKeyData;
    hash.bhp256 r33 into r34 as field;
    get.or_use balances[r34] 0u128 into r35;
    add r35 r23 into r36;
    set r36 into balances[r34];

function swap_exact_private_for_private:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.private;
    input r5 as address.public;
    is.neq r0.token r1 into r6;
    assert.eq r6 true ;
    gt r2 0u128 into r7;
    assert.eq r7 true ;
    cast r4 r1 r3 into r8 as PrivateToken.record;
    sub r0.amount r2 into r9;
    cast r0.owner r0.token r9 into r10 as PrivateToken.record;
    async swap_exact_private_for_private r0.token r1 r2 r3 r5 into r11;
    output r8 as PrivateToken.record;
    output r10 as PrivateToken.record;
    output r11 as testalphav1x1.aleo/swap_exact_private_for_private.future;

finalize swap_exact_private_for_private:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    ternary r5 r0 r1 into r6;
    lt r0 r1 into r7;
    ternary r7 r1 r0 into r8;
    lt r6 r8 into r9;
    assert.eq r9 true ;
    cast r6 r8 into r10 as PairKeyData;
    hash.bhp256 r10 into r11 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r11 into r12 as TokenIdData;
    hash.bhp256 r12 into r13 as field;
    get pairs[r13] into r14;
    is.eq r6 r0 into r15;
    ternary r15 r14.reserve_a r14.reserve_b into r16;
    is.eq r6 r1 into r17;
    ternary r17 r14.reserve_a r14.reserve_b into r18;
    mul r2 997u128 into r19;
    mul r19 r18 into r20;
    mul r16 1000u128 into r21;
    add r21 r19 into r22;
    div r20 r22 into r23;
    gte r23 r3 into r24;
    assert.eq r24 true ;
    gt r23 0u128 into r25;
    assert.eq r25 true ;
    add r16 r2 into r26;
    sub r18 r23 into r27;
    is.eq r6 r0 into r28;
    ternary r28 r26 r27 into r29;
    is.eq r8 r0 into r30;
    ternary r30 r26 r27 into r31;
    cast r29 r31 r14.last_k into r32 as Pair;
    set r32 into pairs[r13];
    cast r1 r4 into r33 as BalanceKeyData;
    hash.bhp256 r33 into r34 as field;
    sub r23 r3 into r35;
    get.or_use balances[r34] 0u128 into r36;
    add r36 r35 into r37;
    set r37 into balances[r34];

function swap_tokens_for_exact_tokens:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0 r1 into r5;
    assert.eq r5 true ;
    gt r3 0u128 into r6;
    assert.eq r6 true ;
    async swap_tokens_for_exact_tokens self.caller r0 r1 r2 r3 r4 into r7;
    output r7 as testalphav1x1.aleo/swap_tokens_for_exact_tokens.future;

finalize swap_tokens_for_exact_tokens:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r1 r2 into r6;
    ternary r6 r1 r2 into r7;
    lt r1 r2 into r8;
    ternary r8 r2 r1 into r9;
    lt r7 r9 into r10;
    assert.eq r10 true ;
    cast r7 r9 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r12 into r13 as TokenIdData;
    hash.bhp256 r13 into r14 as field;
    get pairs[r14] into r15;
    is.eq r7 r1 into r16;
    ternary r16 r15.reserve_a r15.reserve_b into r17;
    is.eq r7 r2 into r18;
    ternary r18 r15.reserve_a r15.reserve_b into r19;
    mul r17 r4 into r20;
    mul r20 1000u128 into r21;
    sub r19 r4 into r22;
    mul r22 997u128 into r23;
    div r21 r23 into r24;
    add r24 1u128 into r25;
    lte r25 r3 into r26;
    assert.eq r26 true ;
    gt r25 0u128 into r27;
    assert.eq r27 true ;
    cast r1 r0 into r28 as BalanceKeyData;
    hash.bhp256 r28 into r29 as field;
    get balances[r29] into r30;
    sub r30 r25 into r31;
    set r31 into balances[r29];
    add r17 r25 into r32;
    sub r19 r4 into r33;
    is.eq r7 r1 into r34;
    ternary r34 r32 r33 into r35;
    is.eq r9 r1 into r36;
    ternary r36 r32 r33 into r37;
    cast r35 r37 r15.last_k into r38 as Pair;
    set r38 into pairs[r14];
    cast r2 r5 into r39 as BalanceKeyData;
    hash.bhp256 r39 into r40 as field;
    get.or_use balances[r40] 0u128 into r41;
    add r41 r4 into r42;
    set r42 into balances[r40];

function swap_private_for_exact_public:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as address.public;
    is.neq r0.token r1 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    sub r0.amount r2 into r8;
    cast r0.owner r0.token r8 into r9 as PrivateToken.record;
    async swap_private_for_exact_public r0.token r1 r2 r3 r4 r5 into r10;
    output r9 as PrivateToken.record;
    output r10 as testalphav1x1.aleo/swap_private_for_exact_public.future;

finalize swap_private_for_exact_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as address.public;
    lt r0 r1 into r6;
    ternary r6 r0 r1 into r7;
    lt r0 r1 into r8;
    ternary r8 r1 r0 into r9;
    lt r7 r9 into r10;
    assert.eq r10 true ;
    cast r7 r9 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r12 into r13 as TokenIdData;
    hash.bhp256 r13 into r14 as field;
    get pairs[r14] into r15;
    is.eq r7 r0 into r16;
    ternary r16 r15.reserve_a r15.reserve_b into r17;
    is.eq r7 r1 into r18;
    ternary r18 r15.reserve_a r15.reserve_b into r19;
    mul r17 r3 into r20;
    mul r20 1000u128 into r21;
    sub r19 r3 into r22;
    mul r22 997u128 into r23;
    div r21 r23 into r24;
    add r24 1u128 into r25;
    lte r25 r2 into r26;
    assert.eq r26 true ;
    gt r25 0u128 into r27;
    assert.eq r27 true ;
    cast r0 r5 into r28 as BalanceKeyData;
    hash.bhp256 r28 into r29 as field;
    sub r2 r25 into r30;
    get.or_use balances[r29] 0u128 into r31;
    add r31 r30 into r32;
    set r32 into balances[r29];
    add r17 r25 into r33;
    sub r19 r3 into r34;
    is.eq r7 r0 into r35;
    ternary r35 r33 r34 into r36;
    is.eq r9 r0 into r37;
    ternary r37 r33 r34 into r38;
    cast r36 r38 r15.last_k into r39 as Pair;
    set r39 into pairs[r14];
    cast r1 r4 into r40 as BalanceKeyData;
    hash.bhp256 r40 into r41 as field;
    get.or_use balances[r41] 0u128 into r42;
    add r42 r3 into r43;
    set r43 into balances[r41];

function swap_private_for_exact_private:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.private;
    input r5 as address.public;
    is.neq r0.token r1 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    cast r4 r1 r3 into r8 as PrivateToken.record;
    sub r0.amount r2 into r9;
    cast r0.owner r0.token r9 into r10 as PrivateToken.record;
    async swap_private_for_exact_private r0.token r1 r2 r3 r5 into r11;
    output r8 as PrivateToken.record;
    output r10 as PrivateToken.record;
    output r11 as testalphav1x1.aleo/swap_private_for_exact_private.future;

finalize swap_private_for_exact_private:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    ternary r5 r0 r1 into r6;
    lt r0 r1 into r7;
    ternary r7 r1 r0 into r8;
    lt r6 r8 into r9;
    assert.eq r9 true ;
    cast r6 r8 into r10 as PairKeyData;
    hash.bhp256 r10 into r11 as u128;
    cast aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg aleo1ymtq985dkxw9avwzhzfr55sg3wnecdyxyfd8kjktrawswpe9puxsl86mmg r11 into r12 as TokenIdData;
    hash.bhp256 r12 into r13 as field;
    get pairs[r13] into r14;
    is.eq r6 r0 into r15;
    ternary r15 r14.reserve_a r14.reserve_b into r16;
    is.eq r6 r1 into r17;
    ternary r17 r14.reserve_a r14.reserve_b into r18;
    mul r16 r3 into r19;
    mul r19 1000u128 into r20;
    sub r18 r3 into r21;
    mul r21 997u128 into r22;
    div r20 r22 into r23;
    add r23 1u128 into r24;
    lte r24 r2 into r25;
    assert.eq r25 true ;
    gt r24 0u128 into r26;
    assert.eq r26 true ;
    cast r0 r4 into r27 as BalanceKeyData;
    hash.bhp256 r27 into r28 as field;
    sub r2 r24 into r29;
    get.or_use balances[r28] 0u128 into r30;
    add r30 r29 into r31;
    set r31 into balances[r28];
    add r16 r24 into r32;
    sub r18 r3 into r33;
    is.eq r6 r0 into r34;
    ternary r34 r32 r33 into r35;
    is.eq r8 r0 into r36;
    ternary r36 r32 r33 into r37;
    cast r35 r37 r14.last_k into r38 as Pair;
    set r38 into pairs[r13];
