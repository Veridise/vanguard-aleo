program alphaswap_v1.aleo;

record PrivateToken:
    owner as address.private;
    token as field.private;
    amount as u128.private;

struct TokenInfo:
    name as field;
    symbol as field;
    decimals as u8;
    total_supply as u128;
    admin as address;
    mintable as boolean;
    burnable as boolean;

struct GlobalState:
    admin as address;
    fee_to as address;

struct Pair:
    reserve_a as u128;
    reserve_b as u128;
    last_k as u128;

struct AccountKeyData:
    token as field;
    user as address;

struct ApprovalKeyData:
    token as field;
    payer as address;
    spender as address;

struct PairKeyData:
    token_a as field;
    token_b as field;

struct TokenIdData:
    base as address;
    creator as address;
    salt as u128;

mapping account:
    key as field.public;
    value as u128.public;

mapping approvals:
    key as field.public;
    value as u128.public;

mapping tokens:
    key as field.public;
    value as TokenInfo.public;

mapping global_state:
    key as boolean.public;
    value as GlobalState.public;

mapping pairs:
    key as field.public;
    value as Pair.public;

function create_token:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as boolean.public;
    input r6 as boolean.public;
    input r7 as u128.public;
    gt r0 0field into r8;
    assert.eq r8 true ;
    async create_token r0 r1 r2 r3 r4 r5 r6 self.caller r7 into r9;
    output r9 as alphaswap_v1.aleo/create_token.future;

finalize create_token:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u8.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as boolean.public;
    input r6 as boolean.public;
    input r7 as address.public;
    input r8 as u128.public;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r7 r8 into r9 as TokenIdData;
    hash.bhp256 r9 into r10 as field;
    contains tokens[r10] into r11;
    not r11 into r12;
    assert.eq r12 true ;
    cast r0 r1 r2 r3 r4 r5 r6 into r13 as TokenInfo;
    set r13 into tokens[r10];
    cast r10 r7 into r14 as AccountKeyData;
    hash.bhp256 r14 into r15 as field;
    set r13.total_supply into account[r15];

function transfer_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async transfer_public r0 self.caller r1 r2 into r3;
    output r3 as alphaswap_v1.aleo/transfer_public.future;

finalize transfer_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    contains tokens[r0] into r4;
    assert.eq r4 true ;
    cast r0 r1 into r5 as AccountKeyData;
    hash.bhp256 r5 into r6 as field;
    get account[r6] into r7;
    sub r7 r3 into r8;
    set r8 into account[r6];
    cast r0 r2 into r9 as AccountKeyData;
    hash.bhp256 r9 into r10 as field;
    get.or_use account[r10] 0u128 into r11;
    add r11 r3 into r12;
    set r12 into account[r10];

function approve_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    cast r0 self.caller r1 into r3 as ApprovalKeyData;
    hash.bhp256 r3 into r4 as field;
    async approve_public r0 r4 r2 into r5;
    output r5 as alphaswap_v1.aleo/approve_public.future;

finalize approve_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true ;
    get.or_use approvals[r1] 0u128 into r4;
    sub 340282366920938463463374607431768211455u128 r4 into r5;
    lt r2 r5 into r6;
    add.w r4 r2 into r7;
    ternary r6 r7 340282366920938463463374607431768211455u128 into r8;
    set r8 into approvals[r1];

function unapprove_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    cast r0 self.caller r1 into r3 as ApprovalKeyData;
    hash.bhp256 r3 into r4 as field;
    async unapprove_public r0 r4 r2 into r5;
    output r5 as alphaswap_v1.aleo/unapprove_public.future;

finalize unapprove_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true ;
    get approvals[r1] into r4;
    gt r4 r2 into r5;
    sub.w r4 r2 into r6;
    ternary r5 r6 0u128 into r7;
    set r7 into approvals[r1];

function transfer_from_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    cast r0 r1 self.caller into r4 as ApprovalKeyData;
    hash.bhp256 r4 into r5 as field;
    async transfer_from_public r0 r5 r1 r2 r3 into r6;
    output r6 as alphaswap_v1.aleo/transfer_from_public.future;

finalize transfer_from_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as address.public;
    input r4 as u128.public;
    contains tokens[r0] into r5;
    assert.eq r5 true ;
    get approvals[r1] into r6;
    sub r6 r4 into r7;
    set r7 into approvals[r1];
    cast r0 r2 into r8 as AccountKeyData;
    hash.bhp256 r8 into r9 as field;
    get account[r9] into r10;
    sub r10 r4 into r11;
    set r11 into account[r9];
    cast r0 r3 into r12 as AccountKeyData;
    hash.bhp256 r12 into r13 as field;
    get.or_use account[r13] 0u128 into r14;
    add r14 r4 into r15;
    set r15 into account[r13];

function transfer_private:
    input r0 as PrivateToken.record;
    input r1 as address.private;
    input r2 as u128.private;
    cast r1 r0.token r2 into r3 as PrivateToken.record;
    sub r0.amount r2 into r4;
    cast r0.owner r0.token r4 into r5 as PrivateToken.record;
    output r3 as PrivateToken.record;
    output r5 as PrivateToken.record;

function transfer_public_to_private:
    input r0 as field.public;
    input r1 as address.private;
    input r2 as u128.public;
    cast r1 r0 r2 into r3 as PrivateToken.record;
    async transfer_public_to_private r0 self.caller r2 into r4;
    output r3 as PrivateToken.record;
    output r4 as alphaswap_v1.aleo/transfer_public_to_private.future;

finalize transfer_public_to_private:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true ;
    cast r0 r1 into r4 as AccountKeyData;
    hash.bhp256 r4 into r5 as field;
    get account[r5] into r6;
    sub r6 r2 into r7;
    set r7 into account[r5];

function transfer_private_to_public:
    input r0 as PrivateToken.record;
    input r1 as address.public;
    input r2 as u128.public;
    sub r0.amount r2 into r3;
    cast r0.owner r0.token r3 into r4 as PrivateToken.record;
    async transfer_private_to_public r0.token r1 r2 into r5;
    output r4 as PrivateToken.record;
    output r5 as alphaswap_v1.aleo/transfer_private_to_public.future;

finalize transfer_private_to_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true ;
    cast r0 r1 into r4 as AccountKeyData;
    hash.bhp256 r4 into r5 as field;
    get.or_use account[r5] 0u128 into r6;
    add r6 r2 into r7;
    set r7 into account[r5];

function join:
    input r0 as PrivateToken.record;
    input r1 as PrivateToken.record;
    assert.eq r0.token r1.token ;
    add r0.amount r1.amount into r2;
    cast r0.owner r0.token r2 into r3 as PrivateToken.record;
    output r3 as PrivateToken.record;

function change_token_admin:
    input r0 as field.public;
    input r1 as address.public;
    async change_token_admin self.caller r0 r1 into r2;
    output r2 as alphaswap_v1.aleo/change_token_admin.future;

finalize change_token_admin:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    get tokens[r1] into r3;
    assert.eq r0 r3.admin ;
    cast r3.name r3.symbol r3.decimals r3.total_supply r2 r3.mintable r3.burnable into r4 as TokenInfo;
    set r4 into tokens[r1];

function renounce_mintable:
    input r0 as field.public;
    async renounce_mintable self.caller r0 into r1;
    output r1 as alphaswap_v1.aleo/renounce_mintable.future;

finalize renounce_mintable:
    input r0 as address.public;
    input r1 as field.public;
    get tokens[r1] into r2;
    assert.eq r0 r2.admin ;
    assert.eq r2.mintable true ;
    cast r2.name r2.symbol r2.decimals r2.total_supply r2.admin false r2.burnable into r3 as TokenInfo;
    set r3 into tokens[r1];

function renounce_burnable:
    input r0 as field.public;
    async renounce_burnable self.caller r0 into r1;
    output r1 as alphaswap_v1.aleo/renounce_burnable.future;

finalize renounce_burnable:
    input r0 as address.public;
    input r1 as field.public;
    get tokens[r1] into r2;
    assert.eq r0 r2.admin ;
    assert.eq r2.burnable true ;
    cast r2.name r2.symbol r2.decimals r2.total_supply r2.admin r2.mintable false into r3 as TokenInfo;
    set r3 into tokens[r1];

function mint_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async mint_public self.caller r0 r1 r2 into r3;
    output r3 as alphaswap_v1.aleo/mint_public.future;

finalize mint_public:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as u128.public;
    get tokens[r1] into r4;
    assert.eq r0 r4.admin ;
    assert.eq r4.mintable true ;
    add r4.total_supply r3 into r5;
    cast r4.name r4.symbol r4.decimals r5 r4.admin r4.mintable r4.burnable into r6 as TokenInfo;
    set r6 into tokens[r1];
    cast r1 r2 into r7 as AccountKeyData;
    hash.bhp256 r7 into r8 as field;
    get.or_use account[r8] 0u128 into r9;
    add r9 r3 into r10;
    set r10 into account[r8];

function mint_private:
    input r0 as field.public;
    input r1 as address.private;
    input r2 as u128.public;
    cast r1 r0 r2 into r3 as PrivateToken.record;
    async mint_private self.caller r0 r2 into r4;
    output r3 as PrivateToken.record;
    output r4 as alphaswap_v1.aleo/mint_private.future;

finalize mint_private:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    get tokens[r1] into r3;
    assert.eq r0 r3.admin ;
    assert.eq r3.mintable true ;
    add r3.total_supply r2 into r4;
    cast r3.name r3.symbol r3.decimals r4 r3.admin r3.mintable r3.burnable into r5 as TokenInfo;
    set r5 into tokens[r1];

function burn:
    input r0 as field.public;
    input r1 as u128.public;
    async burn self.caller r0 r1 into r2;
    output r2 as alphaswap_v1.aleo/burn.future;

finalize burn:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    get tokens[r1] into r3;
    assert.eq r3.burnable true ;
    sub r3.total_supply r2 into r4;
    cast r3.name r3.symbol r3.decimals r4 r3.admin r3.mintable r3.burnable into r5 as TokenInfo;
    set r5 into tokens[r1];
    cast r1 r0 into r6 as AccountKeyData;
    hash.bhp256 r6 into r7 as field;
    get account[r7] into r8;
    sub r8 r2 into r9;
    set r9 into account[r7];

function burn_from:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    cast r0 r1 self.caller into r3 as ApprovalKeyData;
    hash.bhp256 r3 into r4 as field;
    async burn_from r0 r4 r1 r2 into r5;
    output r5 as alphaswap_v1.aleo/burn_from.future;

finalize burn_from:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as u128.public;
    get tokens[r0] into r4;
    assert.eq r4.burnable true ;
    get approvals[r1] into r5;
    sub r5 r3 into r6;
    set r6 into approvals[r1];
    sub r4.total_supply r3 into r7;
    cast r4.name r4.symbol r4.decimals r7 r4.admin r4.mintable r4.burnable into r8 as TokenInfo;
    set r8 into tokens[r0];
    cast r0 r2 into r9 as AccountKeyData;
    hash.bhp256 r9 into r10 as field;
    get account[r10] into r11;
    sub r11 r3 into r12;
    set r12 into account[r10];

function init:
    input r0 as address.public;
    assert.eq self.caller aleo1uldp2afc9gnfsxd0r2svaecax8quutny5j6ns2qa80yp5uhsac9q35h7h6 ;
    async init r0 into r1;
    output r1 as alphaswap_v1.aleo/init.future;

finalize init:
    input r0 as address.public;
    contains global_state[true] into r1;
    not r1 into r2;
    assert.eq r2 true ;
    cast r0 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r3 as GlobalState;
    set r3 into global_state[true];

function change_admin:
    input r0 as address.public;
    async change_admin self.caller r0 into r1;
    output r1 as alphaswap_v1.aleo/change_admin.future;

finalize change_admin:
    input r0 as address.public;
    input r1 as address.public;
    get global_state[true] into r2;
    assert.eq r0 r2.admin ;
    cast r1 r2.fee_to into r3 as GlobalState;
    set r3 into global_state[true];

function set_fee_to:
    input r0 as address.public;
    async set_fee_to self.caller r0 into r1;
    output r1 as alphaswap_v1.aleo/set_fee_to.future;

finalize set_fee_to:
    input r0 as address.public;
    input r1 as address.public;
    get global_state[true] into r2;
    assert.eq r0 r2.admin ;
    cast r2.admin r1 into r3 as GlobalState;
    set r3 into global_state[true];

function create_pair:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    async create_pair self.caller r0 r1 r2 r3 r4 into r8;
    output r8 as alphaswap_v1.aleo/create_pair.future;

finalize create_pair:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r1 r2 into r6;
    assert.eq r6 true ;
    cast r1 r2 into r7 as PairKeyData;
    hash.bhp256 r7 into r8 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r8 into r9 as TokenIdData;
    hash.bhp256 r9 into r10 as field;
    contains pairs[r10] into r11;
    not r11 into r12;
    assert.eq r12 true ;
    contains tokens[r10] into r13;
    not r13 into r14;
    assert.eq r14 true ;
    mul r3 r4 into r15;
    is.eq r15 0u128 into r16;
    is.eq r15 0u128 into r17;
    ternary r17 1u128 r15 into r18;
    shr r18 64u32 into r19;
    gt r19 0u128 into r20;
    shr r18 64u32 into r21;
    add 0u32 64u32 into r22;
    ternary r20 r21 r18 into r23;
    ternary r20 r22 0u32 into r24;
    shr r23 32u32 into r25;
    gt r25 0u128 into r26;
    shr r23 32u32 into r27;
    add r24 32u32 into r28;
    ternary r26 r27 r23 into r29;
    ternary r26 r28 r24 into r30;
    shr r29 16u32 into r31;
    gt r31 0u128 into r32;
    shr r29 16u32 into r33;
    add r30 16u32 into r34;
    ternary r32 r33 r29 into r35;
    ternary r32 r34 r30 into r36;
    shr r35 8u32 into r37;
    gt r37 0u128 into r38;
    shr r35 8u32 into r39;
    add r36 8u32 into r40;
    ternary r38 r39 r35 into r41;
    ternary r38 r40 r36 into r42;
    shr r41 4u32 into r43;
    gt r43 0u128 into r44;
    shr r41 4u32 into r45;
    add r42 4u32 into r46;
    ternary r44 r45 r41 into r47;
    ternary r44 r46 r42 into r48;
    shr r47 2u32 into r49;
    gt r49 0u128 into r50;
    shr r47 2u32 into r51;
    add r48 2u32 into r52;
    ternary r50 r51 r47 into r53;
    ternary r50 r52 r48 into r54;
    shr r53 1u32 into r55;
    gt r55 0u128 into r56;
    add r54 1u32 into r57;
    ternary r56 r57 r54 into r58;
    div r58 2u32 into r59;
    shl 1u128 r59 into r60;
    div r18 r60 into r61;
    add r60 r61 into r62;
    shr r62 1u32 into r63;
    div r18 r63 into r64;
    add r63 r64 into r65;
    shr r65 1u32 into r66;
    div r18 r66 into r67;
    add r66 r67 into r68;
    shr r68 1u32 into r69;
    div r18 r69 into r70;
    add r69 r70 into r71;
    shr r71 1u32 into r72;
    div r18 r72 into r73;
    add r72 r73 into r74;
    shr r74 1u32 into r75;
    div r18 r75 into r76;
    add r75 r76 into r77;
    shr r77 1u32 into r78;
    div r18 r78 into r79;
    add r78 r79 into r80;
    shr r80 1u32 into r81;
    div r18 r81 into r82;
    lt r81 r82 into r83;
    ternary r83 r81 r82 into r84;
    ternary r16 0u128 r84 into r85;
    gt r85 1000u128 into r86;
    assert.eq r86 true ;
    cast r1 r0 into r87 as AccountKeyData;
    hash.bhp256 r87 into r88 as field;
    get account[r88] into r89;
    sub r89 r3 into r90;
    set r90 into account[r88];
    cast r2 r0 into r91 as AccountKeyData;
    hash.bhp256 r91 into r92 as field;
    get account[r92] into r93;
    sub r93 r4 into r94;
    set r94 into account[r92];
    get global_state[true] into r95;
    is.eq r95.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r96;
    mul r3 r4 into r97;
    ternary r96 0u128 r97 into r98;
    cast r3 r4 r98 into r99 as Pair;
    set r99 into pairs[r10];
    cast 5183390837101146826025518328178field 4281168field 6u8 r85 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc false false into r100 as TokenInfo;
    set r100 into tokens[r10];
    cast r10 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r101 as AccountKeyData;
    hash.bhp256 r101 into r102 as field;
    get.or_use account[r102] 0u128 into r103;
    add r103 1000u128 into r104;
    set r104 into account[r102];
    cast r10 r5 into r105 as AccountKeyData;
    hash.bhp256 r105 into r106 as field;
    get.or_use account[r106] 0u128 into r107;
    add r107 r85 into r108;
    sub r108 1000u128 into r109;
    set r109 into account[r106];

function create_pair_privately:
    input r0 as PrivateToken.record;
    input r1 as PrivateToken.record;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.private;
    lt r0.token r1.token into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    mul r2 r3 into r8;
    is.eq r8 0u128 into r9;
    is.eq r8 0u128 into r10;
    ternary r10 1u128 r8 into r11;
    shr r11 64u32 into r12;
    gt r12 0u128 into r13;
    shr r11 64u32 into r14;
    add 0u32 64u32 into r15;
    ternary r13 r14 r11 into r16;
    ternary r13 r15 0u32 into r17;
    shr r16 32u32 into r18;
    gt r18 0u128 into r19;
    shr r16 32u32 into r20;
    add r17 32u32 into r21;
    ternary r19 r20 r16 into r22;
    ternary r19 r21 r17 into r23;
    shr r22 16u32 into r24;
    gt r24 0u128 into r25;
    shr r22 16u32 into r26;
    add r23 16u32 into r27;
    ternary r25 r26 r22 into r28;
    ternary r25 r27 r23 into r29;
    shr r28 8u32 into r30;
    gt r30 0u128 into r31;
    shr r28 8u32 into r32;
    add r29 8u32 into r33;
    ternary r31 r32 r28 into r34;
    ternary r31 r33 r29 into r35;
    shr r34 4u32 into r36;
    gt r36 0u128 into r37;
    shr r34 4u32 into r38;
    add r35 4u32 into r39;
    ternary r37 r38 r34 into r40;
    ternary r37 r39 r35 into r41;
    shr r40 2u32 into r42;
    gt r42 0u128 into r43;
    shr r40 2u32 into r44;
    add r41 2u32 into r45;
    ternary r43 r44 r40 into r46;
    ternary r43 r45 r41 into r47;
    shr r46 1u32 into r48;
    gt r48 0u128 into r49;
    add r47 1u32 into r50;
    ternary r49 r50 r47 into r51;
    div r51 2u32 into r52;
    shl 1u128 r52 into r53;
    div r11 r53 into r54;
    add r53 r54 into r55;
    shr r55 1u32 into r56;
    div r11 r56 into r57;
    add r56 r57 into r58;
    shr r58 1u32 into r59;
    div r11 r59 into r60;
    add r59 r60 into r61;
    shr r61 1u32 into r62;
    div r11 r62 into r63;
    add r62 r63 into r64;
    shr r64 1u32 into r65;
    div r11 r65 into r66;
    add r65 r66 into r67;
    shr r67 1u32 into r68;
    div r11 r68 into r69;
    add r68 r69 into r70;
    shr r70 1u32 into r71;
    div r11 r71 into r72;
    add r71 r72 into r73;
    shr r73 1u32 into r74;
    div r11 r74 into r75;
    lt r74 r75 into r76;
    ternary r76 r74 r75 into r77;
    ternary r9 0u128 r77 into r78;
    gt r78 1000u128 into r79;
    assert.eq r79 true ;
    sub r0.amount r2 into r80;
    cast r0.owner r0.token r80 into r81 as PrivateToken.record;
    sub r1.amount r3 into r82;
    cast r1.owner r1.token r82 into r83 as PrivateToken.record;
    lt r0.token r1.token into r84;
    assert.eq r84 true ;
    cast r0.token r1.token into r85 as PairKeyData;
    hash.bhp256 r85 into r86 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r86 into r87 as TokenIdData;
    hash.bhp256 r87 into r88 as field;
    sub r78 1000u128 into r89;
    cast r4 r88 r89 into r90 as PrivateToken.record;
    async create_pair_privately r0.token r1.token r2 r3 r88 r78 into r91;
    output r90 as PrivateToken.record;
    output r81 as PrivateToken.record;
    output r83 as PrivateToken.record;
    output r91 as alphaswap_v1.aleo/create_pair_privately.future;

finalize create_pair_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as field.public;
    input r5 as u128.public;
    contains pairs[r4] into r6;
    not r6 into r7;
    assert.eq r7 true ;
    contains tokens[r4] into r8;
    not r8 into r9;
    assert.eq r9 true ;
    get global_state[true] into r10;
    is.eq r10.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r11;
    mul r2 r3 into r12;
    ternary r11 0u128 r12 into r13;
    cast r2 r3 r13 into r14 as Pair;
    set r14 into pairs[r4];
    cast 5183390837101146826025518328178field 4281168field 6u8 r5 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc false false into r15 as TokenInfo;
    set r15 into tokens[r4];
    cast r4 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r16 as AccountKeyData;
    hash.bhp256 r16 into r17 as field;
    get.or_use account[r17] 0u128 into r18;
    add r18 1000u128 into r19;
    set r19 into account[r17];

function add_liquidity:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.public;
    lt r0 r1 into r7;
    assert.eq r7 true ;
    gt r2 0u128 into r8;
    gte r2 r4 into r9;
    and r8 r9 into r10;
    assert.eq r10 true ;
    gt r3 0u128 into r11;
    gte r3 r5 into r12;
    and r11 r12 into r13;
    assert.eq r13 true ;
    async add_liquidity self.caller r0 r1 r2 r3 r4 r5 r6 into r14;
    output r14 as alphaswap_v1.aleo/add_liquidity.future;

finalize add_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as u128.public;
    input r7 as address.public;
    lt r1 r2 into r8;
    assert.eq r8 true ;
    cast r1 r2 into r9 as PairKeyData;
    hash.bhp256 r9 into r10 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r10 into r11 as TokenIdData;
    hash.bhp256 r11 into r12 as field;
    get pairs[r12] into r13;
    get tokens[r12] into r14;
    get global_state[true] into r15;
    is.eq r15.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r16;
    mul r13.reserve_a r13.reserve_b into r17;
    is.eq r17 0u128 into r18;
    is.eq r17 0u128 into r19;
    ternary r19 1u128 r17 into r20;
    shr r20 64u32 into r21;
    gt r21 0u128 into r22;
    shr r20 64u32 into r23;
    add 0u32 64u32 into r24;
    ternary r22 r23 r20 into r25;
    ternary r22 r24 0u32 into r26;
    shr r25 32u32 into r27;
    gt r27 0u128 into r28;
    shr r25 32u32 into r29;
    add r26 32u32 into r30;
    ternary r28 r29 r25 into r31;
    ternary r28 r30 r26 into r32;
    shr r31 16u32 into r33;
    gt r33 0u128 into r34;
    shr r31 16u32 into r35;
    add r32 16u32 into r36;
    ternary r34 r35 r31 into r37;
    ternary r34 r36 r32 into r38;
    shr r37 8u32 into r39;
    gt r39 0u128 into r40;
    shr r37 8u32 into r41;
    add r38 8u32 into r42;
    ternary r40 r41 r37 into r43;
    ternary r40 r42 r38 into r44;
    shr r43 4u32 into r45;
    gt r45 0u128 into r46;
    shr r43 4u32 into r47;
    add r44 4u32 into r48;
    ternary r46 r47 r43 into r49;
    ternary r46 r48 r44 into r50;
    shr r49 2u32 into r51;
    gt r51 0u128 into r52;
    shr r49 2u32 into r53;
    add r50 2u32 into r54;
    ternary r52 r53 r49 into r55;
    ternary r52 r54 r50 into r56;
    shr r55 1u32 into r57;
    gt r57 0u128 into r58;
    add r56 1u32 into r59;
    ternary r58 r59 r56 into r60;
    div r60 2u32 into r61;
    shl 1u128 r61 into r62;
    div r20 r62 into r63;
    add r62 r63 into r64;
    shr r64 1u32 into r65;
    div r20 r65 into r66;
    add r65 r66 into r67;
    shr r67 1u32 into r68;
    div r20 r68 into r69;
    add r68 r69 into r70;
    shr r70 1u32 into r71;
    div r20 r71 into r72;
    add r71 r72 into r73;
    shr r73 1u32 into r74;
    div r20 r74 into r75;
    add r74 r75 into r76;
    shr r76 1u32 into r77;
    div r20 r77 into r78;
    add r77 r78 into r79;
    shr r79 1u32 into r80;
    div r20 r80 into r81;
    add r80 r81 into r82;
    shr r82 1u32 into r83;
    div r20 r83 into r84;
    lt r83 r84 into r85;
    ternary r85 r83 r84 into r86;
    ternary r18 0u128 r86 into r87;
    ternary r16 0u128 r87 into r88;
    is.eq r13.last_k 0u128 into r89;
    is.eq r13.last_k 0u128 into r90;
    ternary r90 1u128 r13.last_k into r91;
    shr r91 64u32 into r92;
    gt r92 0u128 into r93;
    shr r91 64u32 into r94;
    add 0u32 64u32 into r95;
    ternary r93 r94 r91 into r96;
    ternary r93 r95 0u32 into r97;
    shr r96 32u32 into r98;
    gt r98 0u128 into r99;
    shr r96 32u32 into r100;
    add r97 32u32 into r101;
    ternary r99 r100 r96 into r102;
    ternary r99 r101 r97 into r103;
    shr r102 16u32 into r104;
    gt r104 0u128 into r105;
    shr r102 16u32 into r106;
    add r103 16u32 into r107;
    ternary r105 r106 r102 into r108;
    ternary r105 r107 r103 into r109;
    shr r108 8u32 into r110;
    gt r110 0u128 into r111;
    shr r108 8u32 into r112;
    add r109 8u32 into r113;
    ternary r111 r112 r108 into r114;
    ternary r111 r113 r109 into r115;
    shr r114 4u32 into r116;
    gt r116 0u128 into r117;
    shr r114 4u32 into r118;
    add r115 4u32 into r119;
    ternary r117 r118 r114 into r120;
    ternary r117 r119 r115 into r121;
    shr r120 2u32 into r122;
    gt r122 0u128 into r123;
    shr r120 2u32 into r124;
    add r121 2u32 into r125;
    ternary r123 r124 r120 into r126;
    ternary r123 r125 r121 into r127;
    shr r126 1u32 into r128;
    gt r128 0u128 into r129;
    add r127 1u32 into r130;
    ternary r129 r130 r127 into r131;
    div r131 2u32 into r132;
    shl 1u128 r132 into r133;
    div r91 r133 into r134;
    add r133 r134 into r135;
    shr r135 1u32 into r136;
    div r91 r136 into r137;
    add r136 r137 into r138;
    shr r138 1u32 into r139;
    div r91 r139 into r140;
    add r139 r140 into r141;
    shr r141 1u32 into r142;
    div r91 r142 into r143;
    add r142 r143 into r144;
    shr r144 1u32 into r145;
    div r91 r145 into r146;
    add r145 r146 into r147;
    shr r147 1u32 into r148;
    div r91 r148 into r149;
    add r148 r149 into r150;
    shr r150 1u32 into r151;
    div r91 r151 into r152;
    add r151 r152 into r153;
    shr r153 1u32 into r154;
    div r91 r154 into r155;
    lt r154 r155 into r156;
    ternary r156 r154 r155 into r157;
    ternary r89 0u128 r157 into r158;
    lte r88 r158 into r159;
    sub.w r88 r158 into r160;
    ternary r159 0u128 r160 into r161;
    mul r88 5u128 into r162;
    add r162 r158 into r163;
    is.eq r163 0u128 into r164;
    ternary r164 1u128 r163 into r165;
    div 340282366920938463463374607431768211455u128 r14.total_supply into r166;
    gte r166 r161 into r167;
    mul.w r14.total_supply r161 into r168;
    div r168 r165 into r169;
    ternary r167 r169 0u128 into r170;
    cast r12 r15.fee_to into r171 as AccountKeyData;
    hash.bhp256 r171 into r172 as field;
    get.or_use account[r172] 0u128 into r173;
    add r173 r170 into r174;
    set r174 into account[r172];
    add r14.total_supply r170 into r175;
    mul r3 r175 into r176;
    div r176 r13.reserve_a into r177;
    mul r4 r175 into r178;
    div r178 r13.reserve_b into r179;
    lte r177 r179 into r180;
    ternary r180 r177 r179 into r181;
    lte r177 r181 into r182;
    mul r181 r13.reserve_a into r183;
    add r183 r175 into r184;
    sub r184 1u128 into r185;
    div r185 r175 into r186;
    ternary r182 r3 r186 into r187;
    lte r179 r181 into r188;
    mul r181 r13.reserve_b into r189;
    add r189 r175 into r190;
    sub r190 1u128 into r191;
    div r191 r175 into r192;
    ternary r188 r4 r192 into r193;
    gt r181 0u128 into r194;
    assert.eq r194 true ;
    gte r187 r5 into r195;
    assert.eq r195 true ;
    gte r193 r6 into r196;
    assert.eq r196 true ;
    cast r1 r0 into r197 as AccountKeyData;
    hash.bhp256 r197 into r198 as field;
    get account[r198] into r199;
    sub r199 r187 into r200;
    set r200 into account[r198];
    cast r2 r0 into r201 as AccountKeyData;
    hash.bhp256 r201 into r202 as field;
    get account[r202] into r203;
    sub r203 r193 into r204;
    set r204 into account[r202];
    cast r12 r7 into r205 as AccountKeyData;
    hash.bhp256 r205 into r206 as field;
    get.or_use account[r206] 0u128 into r207;
    add r207 r181 into r208;
    set r208 into account[r206];
    add r175 r181 into r209;
    cast r14.name r14.symbol r14.decimals r209 r14.admin r14.mintable r14.burnable into r210 as TokenInfo;
    set r210 into tokens[r12];
    add r13.reserve_a r187 into r211;
    add r13.reserve_b r193 into r212;
    mul r211 r212 into r213;
    assert.neq r213 0u128 ;
    is.eq r15.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r214;
    mul r211 r212 into r215;
    ternary r214 0u128 r215 into r216;
    cast r211 r212 r216 into r217 as Pair;
    set r217 into pairs[r12];

function add_liquidity_privately:
    input r0 as PrivateToken.record;
    input r1 as PrivateToken.record;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as u128.public;
    input r7 as address.private;
    input r8 as address.public;
    lt r0.token r1.token into r9;
    assert.eq r9 true ;
    gt r2 0u128 into r10;
    gte r2 r4 into r11;
    and r10 r11 into r12;
    assert.eq r12 true ;
    gt r3 0u128 into r13;
    gte r3 r5 into r14;
    and r13 r14 into r15;
    assert.eq r15 true ;
    gt r6 0u128 into r16;
    assert.eq r16 true ;
    sub r0.amount r2 into r17;
    cast r0.owner r0.token r17 into r18 as PrivateToken.record;
    sub r1.amount r3 into r19;
    cast r1.owner r1.token r19 into r20 as PrivateToken.record;
    lt r0.token r1.token into r21;
    assert.eq r21 true ;
    cast r0.token r1.token into r22 as PairKeyData;
    hash.bhp256 r22 into r23 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r23 into r24 as TokenIdData;
    hash.bhp256 r24 into r25 as field;
    cast r7 r25 r6 into r26 as PrivateToken.record;
    async add_liquidity_privately r0.token r1.token r25 r2 r3 r4 r5 r6 r8 into r27;
    output r26 as PrivateToken.record;
    output r18 as PrivateToken.record;
    output r20 as PrivateToken.record;
    output r27 as alphaswap_v1.aleo/add_liquidity_privately.future;

finalize add_liquidity_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as u128.public;
    input r7 as u128.public;
    input r8 as address.public;
    get pairs[r2] into r9;
    get tokens[r2] into r10;
    get global_state[true] into r11;
    is.eq r11.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r12;
    mul r9.reserve_a r9.reserve_b into r13;
    is.eq r13 0u128 into r14;
    is.eq r13 0u128 into r15;
    ternary r15 1u128 r13 into r16;
    shr r16 64u32 into r17;
    gt r17 0u128 into r18;
    shr r16 64u32 into r19;
    add 0u32 64u32 into r20;
    ternary r18 r19 r16 into r21;
    ternary r18 r20 0u32 into r22;
    shr r21 32u32 into r23;
    gt r23 0u128 into r24;
    shr r21 32u32 into r25;
    add r22 32u32 into r26;
    ternary r24 r25 r21 into r27;
    ternary r24 r26 r22 into r28;
    shr r27 16u32 into r29;
    gt r29 0u128 into r30;
    shr r27 16u32 into r31;
    add r28 16u32 into r32;
    ternary r30 r31 r27 into r33;
    ternary r30 r32 r28 into r34;
    shr r33 8u32 into r35;
    gt r35 0u128 into r36;
    shr r33 8u32 into r37;
    add r34 8u32 into r38;
    ternary r36 r37 r33 into r39;
    ternary r36 r38 r34 into r40;
    shr r39 4u32 into r41;
    gt r41 0u128 into r42;
    shr r39 4u32 into r43;
    add r40 4u32 into r44;
    ternary r42 r43 r39 into r45;
    ternary r42 r44 r40 into r46;
    shr r45 2u32 into r47;
    gt r47 0u128 into r48;
    shr r45 2u32 into r49;
    add r46 2u32 into r50;
    ternary r48 r49 r45 into r51;
    ternary r48 r50 r46 into r52;
    shr r51 1u32 into r53;
    gt r53 0u128 into r54;
    add r52 1u32 into r55;
    ternary r54 r55 r52 into r56;
    div r56 2u32 into r57;
    shl 1u128 r57 into r58;
    div r16 r58 into r59;
    add r58 r59 into r60;
    shr r60 1u32 into r61;
    div r16 r61 into r62;
    add r61 r62 into r63;
    shr r63 1u32 into r64;
    div r16 r64 into r65;
    add r64 r65 into r66;
    shr r66 1u32 into r67;
    div r16 r67 into r68;
    add r67 r68 into r69;
    shr r69 1u32 into r70;
    div r16 r70 into r71;
    add r70 r71 into r72;
    shr r72 1u32 into r73;
    div r16 r73 into r74;
    add r73 r74 into r75;
    shr r75 1u32 into r76;
    div r16 r76 into r77;
    add r76 r77 into r78;
    shr r78 1u32 into r79;
    div r16 r79 into r80;
    lt r79 r80 into r81;
    ternary r81 r79 r80 into r82;
    ternary r14 0u128 r82 into r83;
    ternary r12 0u128 r83 into r84;
    is.eq r9.last_k 0u128 into r85;
    is.eq r9.last_k 0u128 into r86;
    ternary r86 1u128 r9.last_k into r87;
    shr r87 64u32 into r88;
    gt r88 0u128 into r89;
    shr r87 64u32 into r90;
    add 0u32 64u32 into r91;
    ternary r89 r90 r87 into r92;
    ternary r89 r91 0u32 into r93;
    shr r92 32u32 into r94;
    gt r94 0u128 into r95;
    shr r92 32u32 into r96;
    add r93 32u32 into r97;
    ternary r95 r96 r92 into r98;
    ternary r95 r97 r93 into r99;
    shr r98 16u32 into r100;
    gt r100 0u128 into r101;
    shr r98 16u32 into r102;
    add r99 16u32 into r103;
    ternary r101 r102 r98 into r104;
    ternary r101 r103 r99 into r105;
    shr r104 8u32 into r106;
    gt r106 0u128 into r107;
    shr r104 8u32 into r108;
    add r105 8u32 into r109;
    ternary r107 r108 r104 into r110;
    ternary r107 r109 r105 into r111;
    shr r110 4u32 into r112;
    gt r112 0u128 into r113;
    shr r110 4u32 into r114;
    add r111 4u32 into r115;
    ternary r113 r114 r110 into r116;
    ternary r113 r115 r111 into r117;
    shr r116 2u32 into r118;
    gt r118 0u128 into r119;
    shr r116 2u32 into r120;
    add r117 2u32 into r121;
    ternary r119 r120 r116 into r122;
    ternary r119 r121 r117 into r123;
    shr r122 1u32 into r124;
    gt r124 0u128 into r125;
    add r123 1u32 into r126;
    ternary r125 r126 r123 into r127;
    div r127 2u32 into r128;
    shl 1u128 r128 into r129;
    div r87 r129 into r130;
    add r129 r130 into r131;
    shr r131 1u32 into r132;
    div r87 r132 into r133;
    add r132 r133 into r134;
    shr r134 1u32 into r135;
    div r87 r135 into r136;
    add r135 r136 into r137;
    shr r137 1u32 into r138;
    div r87 r138 into r139;
    add r138 r139 into r140;
    shr r140 1u32 into r141;
    div r87 r141 into r142;
    add r141 r142 into r143;
    shr r143 1u32 into r144;
    div r87 r144 into r145;
    add r144 r145 into r146;
    shr r146 1u32 into r147;
    div r87 r147 into r148;
    add r147 r148 into r149;
    shr r149 1u32 into r150;
    div r87 r150 into r151;
    lt r150 r151 into r152;
    ternary r152 r150 r151 into r153;
    ternary r85 0u128 r153 into r154;
    lte r84 r154 into r155;
    sub.w r84 r154 into r156;
    ternary r155 0u128 r156 into r157;
    mul r84 5u128 into r158;
    add r158 r154 into r159;
    is.eq r159 0u128 into r160;
    ternary r160 1u128 r159 into r161;
    div 340282366920938463463374607431768211455u128 r10.total_supply into r162;
    gte r162 r157 into r163;
    mul.w r10.total_supply r157 into r164;
    div r164 r161 into r165;
    ternary r163 r165 0u128 into r166;
    cast r2 r11.fee_to into r167 as AccountKeyData;
    hash.bhp256 r167 into r168 as field;
    get.or_use account[r168] 0u128 into r169;
    add r169 r166 into r170;
    set r170 into account[r168];
    add r10.total_supply r166 into r171;
    mul r3 r171 into r172;
    div r172 r9.reserve_a into r173;
    mul r4 r171 into r174;
    div r174 r9.reserve_b into r175;
    lte r173 r175 into r176;
    ternary r176 r173 r175 into r177;
    lte r173 r177 into r178;
    mul r177 r9.reserve_a into r179;
    add r179 r171 into r180;
    sub r180 1u128 into r181;
    div r181 r171 into r182;
    ternary r178 r3 r182 into r183;
    lte r175 r177 into r184;
    mul r177 r9.reserve_b into r185;
    add r185 r171 into r186;
    sub r186 1u128 into r187;
    div r187 r171 into r188;
    ternary r184 r4 r188 into r189;
    gte r177 r7 into r190;
    assert.eq r190 true ;
    gte r3 r183 into r191;
    gte r183 r5 into r192;
    and r191 r192 into r193;
    assert.eq r193 true ;
    gte r4 r189 into r194;
    gte r189 r6 into r195;
    and r194 r195 into r196;
    assert.eq r196 true ;
    cast r0 r8 into r197 as AccountKeyData;
    hash.bhp256 r197 into r198 as field;
    get.or_use account[r198] 0u128 into r199;
    add r199 r3 into r200;
    sub r200 r183 into r201;
    set r201 into account[r198];
    cast r1 r8 into r202 as AccountKeyData;
    hash.bhp256 r202 into r203 as field;
    get.or_use account[r203] 0u128 into r204;
    add r204 r4 into r205;
    sub r205 r189 into r206;
    set r206 into account[r203];
    cast r2 r8 into r207 as AccountKeyData;
    hash.bhp256 r207 into r208 as field;
    get.or_use account[r208] 0u128 into r209;
    add r209 r177 into r210;
    sub r210 r7 into r211;
    set r211 into account[r208];
    add r171 r177 into r212;
    cast r10.name r10.symbol r10.decimals r212 r10.admin r10.mintable r10.burnable into r213 as TokenInfo;
    set r213 into tokens[r2];
    add r9.reserve_a r183 into r214;
    add r9.reserve_b r189 into r215;
    mul r214 r215 into r216;
    assert.neq r216 0u128 ;
    is.eq r11.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r217;
    mul r214 r215 into r218;
    ternary r217 0u128 r218 into r219;
    cast r214 r215 r219 into r220 as Pair;
    set r220 into pairs[r2];

function remove_liquidity:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r0 r1 into r6;
    assert.eq r6 true ;
    gt r2 0u128 into r7;
    assert.eq r7 true ;
    async remove_liquidity self.caller r0 r1 r2 r3 r4 r5 into r8;
    output r8 as alphaswap_v1.aleo/remove_liquidity.future;

finalize remove_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.public;
    lt r1 r2 into r7;
    assert.eq r7 true ;
    cast r1 r2 into r8 as PairKeyData;
    hash.bhp256 r8 into r9 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r9 into r10 as TokenIdData;
    hash.bhp256 r10 into r11 as field;
    get tokens[r11] into r12;
    get pairs[r11] into r13;
    get global_state[true] into r14;
    is.eq r14.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r15;
    mul r13.reserve_a r13.reserve_b into r16;
    is.eq r16 0u128 into r17;
    is.eq r16 0u128 into r18;
    ternary r18 1u128 r16 into r19;
    shr r19 64u32 into r20;
    gt r20 0u128 into r21;
    shr r19 64u32 into r22;
    add 0u32 64u32 into r23;
    ternary r21 r22 r19 into r24;
    ternary r21 r23 0u32 into r25;
    shr r24 32u32 into r26;
    gt r26 0u128 into r27;
    shr r24 32u32 into r28;
    add r25 32u32 into r29;
    ternary r27 r28 r24 into r30;
    ternary r27 r29 r25 into r31;
    shr r30 16u32 into r32;
    gt r32 0u128 into r33;
    shr r30 16u32 into r34;
    add r31 16u32 into r35;
    ternary r33 r34 r30 into r36;
    ternary r33 r35 r31 into r37;
    shr r36 8u32 into r38;
    gt r38 0u128 into r39;
    shr r36 8u32 into r40;
    add r37 8u32 into r41;
    ternary r39 r40 r36 into r42;
    ternary r39 r41 r37 into r43;
    shr r42 4u32 into r44;
    gt r44 0u128 into r45;
    shr r42 4u32 into r46;
    add r43 4u32 into r47;
    ternary r45 r46 r42 into r48;
    ternary r45 r47 r43 into r49;
    shr r48 2u32 into r50;
    gt r50 0u128 into r51;
    shr r48 2u32 into r52;
    add r49 2u32 into r53;
    ternary r51 r52 r48 into r54;
    ternary r51 r53 r49 into r55;
    shr r54 1u32 into r56;
    gt r56 0u128 into r57;
    add r55 1u32 into r58;
    ternary r57 r58 r55 into r59;
    div r59 2u32 into r60;
    shl 1u128 r60 into r61;
    div r19 r61 into r62;
    add r61 r62 into r63;
    shr r63 1u32 into r64;
    div r19 r64 into r65;
    add r64 r65 into r66;
    shr r66 1u32 into r67;
    div r19 r67 into r68;
    add r67 r68 into r69;
    shr r69 1u32 into r70;
    div r19 r70 into r71;
    add r70 r71 into r72;
    shr r72 1u32 into r73;
    div r19 r73 into r74;
    add r73 r74 into r75;
    shr r75 1u32 into r76;
    div r19 r76 into r77;
    add r76 r77 into r78;
    shr r78 1u32 into r79;
    div r19 r79 into r80;
    add r79 r80 into r81;
    shr r81 1u32 into r82;
    div r19 r82 into r83;
    lt r82 r83 into r84;
    ternary r84 r82 r83 into r85;
    ternary r17 0u128 r85 into r86;
    ternary r15 0u128 r86 into r87;
    is.eq r13.last_k 0u128 into r88;
    is.eq r13.last_k 0u128 into r89;
    ternary r89 1u128 r13.last_k into r90;
    shr r90 64u32 into r91;
    gt r91 0u128 into r92;
    shr r90 64u32 into r93;
    add 0u32 64u32 into r94;
    ternary r92 r93 r90 into r95;
    ternary r92 r94 0u32 into r96;
    shr r95 32u32 into r97;
    gt r97 0u128 into r98;
    shr r95 32u32 into r99;
    add r96 32u32 into r100;
    ternary r98 r99 r95 into r101;
    ternary r98 r100 r96 into r102;
    shr r101 16u32 into r103;
    gt r103 0u128 into r104;
    shr r101 16u32 into r105;
    add r102 16u32 into r106;
    ternary r104 r105 r101 into r107;
    ternary r104 r106 r102 into r108;
    shr r107 8u32 into r109;
    gt r109 0u128 into r110;
    shr r107 8u32 into r111;
    add r108 8u32 into r112;
    ternary r110 r111 r107 into r113;
    ternary r110 r112 r108 into r114;
    shr r113 4u32 into r115;
    gt r115 0u128 into r116;
    shr r113 4u32 into r117;
    add r114 4u32 into r118;
    ternary r116 r117 r113 into r119;
    ternary r116 r118 r114 into r120;
    shr r119 2u32 into r121;
    gt r121 0u128 into r122;
    shr r119 2u32 into r123;
    add r120 2u32 into r124;
    ternary r122 r123 r119 into r125;
    ternary r122 r124 r120 into r126;
    shr r125 1u32 into r127;
    gt r127 0u128 into r128;
    add r126 1u32 into r129;
    ternary r128 r129 r126 into r130;
    div r130 2u32 into r131;
    shl 1u128 r131 into r132;
    div r90 r132 into r133;
    add r132 r133 into r134;
    shr r134 1u32 into r135;
    div r90 r135 into r136;
    add r135 r136 into r137;
    shr r137 1u32 into r138;
    div r90 r138 into r139;
    add r138 r139 into r140;
    shr r140 1u32 into r141;
    div r90 r141 into r142;
    add r141 r142 into r143;
    shr r143 1u32 into r144;
    div r90 r144 into r145;
    add r144 r145 into r146;
    shr r146 1u32 into r147;
    div r90 r147 into r148;
    add r147 r148 into r149;
    shr r149 1u32 into r150;
    div r90 r150 into r151;
    add r150 r151 into r152;
    shr r152 1u32 into r153;
    div r90 r153 into r154;
    lt r153 r154 into r155;
    ternary r155 r153 r154 into r156;
    ternary r88 0u128 r156 into r157;
    lte r87 r157 into r158;
    sub.w r87 r157 into r159;
    ternary r158 0u128 r159 into r160;
    mul r87 5u128 into r161;
    add r161 r157 into r162;
    is.eq r162 0u128 into r163;
    ternary r163 1u128 r162 into r164;
    div 340282366920938463463374607431768211455u128 r12.total_supply into r165;
    gte r165 r160 into r166;
    mul.w r12.total_supply r160 into r167;
    div r167 r164 into r168;
    ternary r166 r168 0u128 into r169;
    cast r11 r14.fee_to into r170 as AccountKeyData;
    hash.bhp256 r170 into r171 as field;
    get.or_use account[r171] 0u128 into r172;
    add r172 r169 into r173;
    set r173 into account[r171];
    add r12.total_supply r169 into r174;
    mul r3 r13.reserve_a into r175;
    div r175 r174 into r176;
    mul r3 r13.reserve_b into r177;
    div r177 r174 into r178;
    gte r176 r4 into r179;
    gte r178 r5 into r180;
    and r179 r180 into r181;
    assert.eq r181 true ;
    gt r176 0u128 into r182;
    gt r178 0u128 into r183;
    or r182 r183 into r184;
    assert.eq r184 true ;
    cast r11 r0 into r185 as AccountKeyData;
    hash.bhp256 r185 into r186 as field;
    get account[r186] into r187;
    sub r187 r3 into r188;
    set r188 into account[r186];
    sub r174 r3 into r189;
    cast r12.name r12.symbol r12.decimals r189 r12.admin r12.mintable r12.burnable into r190 as TokenInfo;
    set r190 into tokens[r11];
    sub r13.reserve_a r176 into r191;
    sub r13.reserve_b r178 into r192;
    mul r191 r192 into r193;
    assert.neq r193 0u128 ;
    is.eq r14.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r194;
    mul r191 r192 into r195;
    ternary r194 0u128 r195 into r196;
    cast r191 r192 r196 into r197 as Pair;
    set r197 into pairs[r11];
    cast r1 r6 into r198 as AccountKeyData;
    hash.bhp256 r198 into r199 as field;
    cast r2 r6 into r200 as AccountKeyData;
    hash.bhp256 r200 into r201 as field;
    get.or_use account[r199] 0u128 into r202;
    add r202 r176 into r203;
    set r203 into account[r199];
    get.or_use account[r201] 0u128 into r204;
    add r204 r178 into r205;
    set r205 into account[r201];

function remove_liquidity_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as PrivateToken.record;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.private;
    input r7 as address.public;
    lt r0 r1 into r8;
    assert.eq r8 true ;
    gt r3 0u128 into r9;
    assert.eq r9 true ;
    lt r0 r1 into r10;
    assert.eq r10 true ;
    cast r0 r1 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r12 into r13 as TokenIdData;
    hash.bhp256 r13 into r14 as field;
    assert.eq r14 r2.token ;
    cast r6 r0 r4 into r15 as PrivateToken.record;
    cast r6 r1 r5 into r16 as PrivateToken.record;
    sub r2.amount r3 into r17;
    cast r2.owner r14 r17 into r18 as PrivateToken.record;
    async remove_liquidity_privately r0 r1 r14 r3 r4 r5 r7 into r19;
    output r15 as PrivateToken.record;
    output r16 as PrivateToken.record;
    output r18 as PrivateToken.record;
    output r19 as alphaswap_v1.aleo/remove_liquidity_privately.future;

finalize remove_liquidity_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.public;
    get pairs[r2] into r7;
    get tokens[r2] into r8;
    get global_state[true] into r9;
    is.eq r9.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r10;
    mul r7.reserve_a r7.reserve_b into r11;
    is.eq r11 0u128 into r12;
    is.eq r11 0u128 into r13;
    ternary r13 1u128 r11 into r14;
    shr r14 64u32 into r15;
    gt r15 0u128 into r16;
    shr r14 64u32 into r17;
    add 0u32 64u32 into r18;
    ternary r16 r17 r14 into r19;
    ternary r16 r18 0u32 into r20;
    shr r19 32u32 into r21;
    gt r21 0u128 into r22;
    shr r19 32u32 into r23;
    add r20 32u32 into r24;
    ternary r22 r23 r19 into r25;
    ternary r22 r24 r20 into r26;
    shr r25 16u32 into r27;
    gt r27 0u128 into r28;
    shr r25 16u32 into r29;
    add r26 16u32 into r30;
    ternary r28 r29 r25 into r31;
    ternary r28 r30 r26 into r32;
    shr r31 8u32 into r33;
    gt r33 0u128 into r34;
    shr r31 8u32 into r35;
    add r32 8u32 into r36;
    ternary r34 r35 r31 into r37;
    ternary r34 r36 r32 into r38;
    shr r37 4u32 into r39;
    gt r39 0u128 into r40;
    shr r37 4u32 into r41;
    add r38 4u32 into r42;
    ternary r40 r41 r37 into r43;
    ternary r40 r42 r38 into r44;
    shr r43 2u32 into r45;
    gt r45 0u128 into r46;
    shr r43 2u32 into r47;
    add r44 2u32 into r48;
    ternary r46 r47 r43 into r49;
    ternary r46 r48 r44 into r50;
    shr r49 1u32 into r51;
    gt r51 0u128 into r52;
    add r50 1u32 into r53;
    ternary r52 r53 r50 into r54;
    div r54 2u32 into r55;
    shl 1u128 r55 into r56;
    div r14 r56 into r57;
    add r56 r57 into r58;
    shr r58 1u32 into r59;
    div r14 r59 into r60;
    add r59 r60 into r61;
    shr r61 1u32 into r62;
    div r14 r62 into r63;
    add r62 r63 into r64;
    shr r64 1u32 into r65;
    div r14 r65 into r66;
    add r65 r66 into r67;
    shr r67 1u32 into r68;
    div r14 r68 into r69;
    add r68 r69 into r70;
    shr r70 1u32 into r71;
    div r14 r71 into r72;
    add r71 r72 into r73;
    shr r73 1u32 into r74;
    div r14 r74 into r75;
    add r74 r75 into r76;
    shr r76 1u32 into r77;
    div r14 r77 into r78;
    lt r77 r78 into r79;
    ternary r79 r77 r78 into r80;
    ternary r12 0u128 r80 into r81;
    ternary r10 0u128 r81 into r82;
    is.eq r7.last_k 0u128 into r83;
    is.eq r7.last_k 0u128 into r84;
    ternary r84 1u128 r7.last_k into r85;
    shr r85 64u32 into r86;
    gt r86 0u128 into r87;
    shr r85 64u32 into r88;
    add 0u32 64u32 into r89;
    ternary r87 r88 r85 into r90;
    ternary r87 r89 0u32 into r91;
    shr r90 32u32 into r92;
    gt r92 0u128 into r93;
    shr r90 32u32 into r94;
    add r91 32u32 into r95;
    ternary r93 r94 r90 into r96;
    ternary r93 r95 r91 into r97;
    shr r96 16u32 into r98;
    gt r98 0u128 into r99;
    shr r96 16u32 into r100;
    add r97 16u32 into r101;
    ternary r99 r100 r96 into r102;
    ternary r99 r101 r97 into r103;
    shr r102 8u32 into r104;
    gt r104 0u128 into r105;
    shr r102 8u32 into r106;
    add r103 8u32 into r107;
    ternary r105 r106 r102 into r108;
    ternary r105 r107 r103 into r109;
    shr r108 4u32 into r110;
    gt r110 0u128 into r111;
    shr r108 4u32 into r112;
    add r109 4u32 into r113;
    ternary r111 r112 r108 into r114;
    ternary r111 r113 r109 into r115;
    shr r114 2u32 into r116;
    gt r116 0u128 into r117;
    shr r114 2u32 into r118;
    add r115 2u32 into r119;
    ternary r117 r118 r114 into r120;
    ternary r117 r119 r115 into r121;
    shr r120 1u32 into r122;
    gt r122 0u128 into r123;
    add r121 1u32 into r124;
    ternary r123 r124 r121 into r125;
    div r125 2u32 into r126;
    shl 1u128 r126 into r127;
    div r85 r127 into r128;
    add r127 r128 into r129;
    shr r129 1u32 into r130;
    div r85 r130 into r131;
    add r130 r131 into r132;
    shr r132 1u32 into r133;
    div r85 r133 into r134;
    add r133 r134 into r135;
    shr r135 1u32 into r136;
    div r85 r136 into r137;
    add r136 r137 into r138;
    shr r138 1u32 into r139;
    div r85 r139 into r140;
    add r139 r140 into r141;
    shr r141 1u32 into r142;
    div r85 r142 into r143;
    add r142 r143 into r144;
    shr r144 1u32 into r145;
    div r85 r145 into r146;
    add r145 r146 into r147;
    shr r147 1u32 into r148;
    div r85 r148 into r149;
    lt r148 r149 into r150;
    ternary r150 r148 r149 into r151;
    ternary r83 0u128 r151 into r152;
    lte r82 r152 into r153;
    sub.w r82 r152 into r154;
    ternary r153 0u128 r154 into r155;
    mul r82 5u128 into r156;
    add r156 r152 into r157;
    is.eq r157 0u128 into r158;
    ternary r158 1u128 r157 into r159;
    div 340282366920938463463374607431768211455u128 r8.total_supply into r160;
    gte r160 r155 into r161;
    mul.w r8.total_supply r155 into r162;
    div r162 r159 into r163;
    ternary r161 r163 0u128 into r164;
    cast r2 r9.fee_to into r165 as AccountKeyData;
    hash.bhp256 r165 into r166 as field;
    get.or_use account[r166] 0u128 into r167;
    add r167 r164 into r168;
    set r168 into account[r166];
    add r8.total_supply r164 into r169;
    mul r3 r7.reserve_a into r170;
    div r170 r169 into r171;
    mul r3 r7.reserve_b into r172;
    div r172 r169 into r173;
    gte r171 r4 into r174;
    gte r173 r5 into r175;
    and r174 r175 into r176;
    assert.eq r176 true ;
    gt r171 0u128 into r177;
    gt r173 0u128 into r178;
    or r177 r178 into r179;
    assert.eq r179 true ;
    sub r169 r3 into r180;
    cast r8.name r8.symbol r8.decimals r180 r8.admin r8.mintable r8.burnable into r181 as TokenInfo;
    set r181 into tokens[r2];
    sub r7.reserve_a r171 into r182;
    sub r7.reserve_b r173 into r183;
    mul r182 r183 into r184;
    assert.neq r184 0u128 ;
    is.eq r9.fee_to aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r185;
    mul r182 r183 into r186;
    ternary r185 0u128 r186 into r187;
    cast r182 r183 r187 into r188 as Pair;
    set r188 into pairs[r2];
    cast r0 r6 into r189 as AccountKeyData;
    hash.bhp256 r189 into r190 as field;
    cast r1 r6 into r191 as AccountKeyData;
    hash.bhp256 r191 into r192 as field;
    get.or_use account[r190] 0u128 into r193;
    add r193 r171 into r194;
    sub r194 r4 into r195;
    set r195 into account[r190];
    get.or_use account[r192] 0u128 into r196;
    add r196 r173 into r197;
    sub r197 r5 into r198;
    set r198 into account[r192];

function swap_exact_tokens_for_tokens:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0 r1 into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    async swap_exact_tokens_for_tokens self.caller r0 r1 r2 r3 r4 into r7;
    output r7 as alphaswap_v1.aleo/swap_exact_tokens_for_tokens.future;

finalize swap_exact_tokens_for_tokens:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r1 r2 into r6;
    ternary r6 r1 r2 into r7;
    lt r1 r2 into r8;
    ternary r8 r2 r1 into r9;
    lt r7 r9 into r10;
    assert.eq r10 true ;
    cast r7 r9 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r12 into r13 as TokenIdData;
    hash.bhp256 r13 into r14 as field;
    get pairs[r14] into r15;
    is.eq r7 r1 into r16;
    ternary r16 r15.reserve_a r15.reserve_b into r17;
    is.eq r7 r2 into r18;
    ternary r18 r15.reserve_a r15.reserve_b into r19;
    mul r3 997u128 into r20;
    mul r20 r19 into r21;
    mul r17 1000u128 into r22;
    add r22 r20 into r23;
    div r21 r23 into r24;
    gte r24 r4 into r25;
    assert.eq r25 true ;
    gt r24 0u128 into r26;
    assert.eq r26 true ;
    cast r1 r0 into r27 as AccountKeyData;
    hash.bhp256 r27 into r28 as field;
    get account[r28] into r29;
    sub r29 r3 into r30;
    set r30 into account[r28];
    add r17 r3 into r31;
    sub r19 r24 into r32;
    mul r31 r32 into r33;
    assert.neq r33 0u128 ;
    is.eq r7 r1 into r34;
    ternary r34 r31 r32 into r35;
    is.eq r9 r1 into r36;
    ternary r36 r31 r32 into r37;
    cast r35 r37 r15.last_k into r38 as Pair;
    set r38 into pairs[r14];
    cast r2 r5 into r39 as AccountKeyData;
    hash.bhp256 r39 into r40 as field;
    get.or_use account[r40] 0u128 into r41;
    add r41 r24 into r42;
    set r42 into account[r40];

function swap_exact_private_for_public:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0.token r1 into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    sub r0.amount r2 into r7;
    cast r0.owner r0.token r7 into r8 as PrivateToken.record;
    async swap_exact_private_for_public r0.token r1 r2 r3 r4 into r9;
    output r8 as PrivateToken.record;
    output r9 as alphaswap_v1.aleo/swap_exact_private_for_public.future;

finalize swap_exact_private_for_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    ternary r5 r0 r1 into r6;
    lt r0 r1 into r7;
    ternary r7 r1 r0 into r8;
    lt r6 r8 into r9;
    assert.eq r9 true ;
    cast r6 r8 into r10 as PairKeyData;
    hash.bhp256 r10 into r11 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r11 into r12 as TokenIdData;
    hash.bhp256 r12 into r13 as field;
    get pairs[r13] into r14;
    is.eq r6 r0 into r15;
    ternary r15 r14.reserve_a r14.reserve_b into r16;
    is.eq r6 r1 into r17;
    ternary r17 r14.reserve_a r14.reserve_b into r18;
    mul r2 997u128 into r19;
    mul r19 r18 into r20;
    mul r16 1000u128 into r21;
    add r21 r19 into r22;
    div r20 r22 into r23;
    gte r23 r3 into r24;
    assert.eq r24 true ;
    gt r23 0u128 into r25;
    assert.eq r25 true ;
    add r16 r2 into r26;
    sub r18 r23 into r27;
    mul r26 r27 into r28;
    assert.neq r28 0u128 ;
    is.eq r6 r0 into r29;
    ternary r29 r26 r27 into r30;
    is.eq r8 r0 into r31;
    ternary r31 r26 r27 into r32;
    cast r30 r32 r14.last_k into r33 as Pair;
    set r33 into pairs[r13];
    cast r1 r4 into r34 as AccountKeyData;
    hash.bhp256 r34 into r35 as field;
    get.or_use account[r35] 0u128 into r36;
    add r36 r23 into r37;
    set r37 into account[r35];

function swap_exact_private_for_private:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.private;
    input r5 as address.public;
    is.neq r0.token r1 into r6;
    assert.eq r6 true ;
    gt r2 0u128 into r7;
    assert.eq r7 true ;
    cast r4 r1 r3 into r8 as PrivateToken.record;
    sub r0.amount r2 into r9;
    cast r0.owner r0.token r9 into r10 as PrivateToken.record;
    async swap_exact_private_for_private r0.token r1 r2 r3 r5 into r11;
    output r8 as PrivateToken.record;
    output r10 as PrivateToken.record;
    output r11 as alphaswap_v1.aleo/swap_exact_private_for_private.future;

finalize swap_exact_private_for_private:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    ternary r5 r0 r1 into r6;
    lt r0 r1 into r7;
    ternary r7 r1 r0 into r8;
    lt r6 r8 into r9;
    assert.eq r9 true ;
    cast r6 r8 into r10 as PairKeyData;
    hash.bhp256 r10 into r11 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r11 into r12 as TokenIdData;
    hash.bhp256 r12 into r13 as field;
    get pairs[r13] into r14;
    is.eq r6 r0 into r15;
    ternary r15 r14.reserve_a r14.reserve_b into r16;
    is.eq r6 r1 into r17;
    ternary r17 r14.reserve_a r14.reserve_b into r18;
    mul r2 997u128 into r19;
    mul r19 r18 into r20;
    mul r16 1000u128 into r21;
    add r21 r19 into r22;
    div r20 r22 into r23;
    gte r23 r3 into r24;
    assert.eq r24 true ;
    gt r23 0u128 into r25;
    assert.eq r25 true ;
    add r16 r2 into r26;
    sub r18 r23 into r27;
    mul r26 r27 into r28;
    assert.neq r28 0u128 ;
    is.eq r6 r0 into r29;
    ternary r29 r26 r27 into r30;
    is.eq r8 r0 into r31;
    ternary r31 r26 r27 into r32;
    cast r30 r32 r14.last_k into r33 as Pair;
    set r33 into pairs[r13];
    cast r1 r4 into r34 as AccountKeyData;
    hash.bhp256 r34 into r35 as field;
    sub r23 r3 into r36;
    get.or_use account[r35] 0u128 into r37;
    add r37 r36 into r38;
    set r38 into account[r35];

function swap_tokens_for_exact_tokens:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0 r1 into r5;
    assert.eq r5 true ;
    gt r3 0u128 into r6;
    assert.eq r6 true ;
    async swap_tokens_for_exact_tokens self.caller r0 r1 r2 r3 r4 into r7;
    output r7 as alphaswap_v1.aleo/swap_tokens_for_exact_tokens.future;

finalize swap_tokens_for_exact_tokens:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r1 r2 into r6;
    ternary r6 r1 r2 into r7;
    lt r1 r2 into r8;
    ternary r8 r2 r1 into r9;
    lt r7 r9 into r10;
    assert.eq r10 true ;
    cast r7 r9 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r12 into r13 as TokenIdData;
    hash.bhp256 r13 into r14 as field;
    get pairs[r14] into r15;
    is.eq r7 r1 into r16;
    ternary r16 r15.reserve_a r15.reserve_b into r17;
    is.eq r7 r2 into r18;
    ternary r18 r15.reserve_a r15.reserve_b into r19;
    mul r17 r4 into r20;
    mul r20 1000u128 into r21;
    sub r19 r4 into r22;
    mul r22 997u128 into r23;
    div r21 r23 into r24;
    add r24 1u128 into r25;
    lte r25 r3 into r26;
    assert.eq r26 true ;
    gt r25 0u128 into r27;
    assert.eq r27 true ;
    cast r1 r0 into r28 as AccountKeyData;
    hash.bhp256 r28 into r29 as field;
    get account[r29] into r30;
    sub r30 r25 into r31;
    set r31 into account[r29];
    add r17 r25 into r32;
    sub r19 r4 into r33;
    mul r32 r33 into r34;
    assert.neq r34 0u128 ;
    is.eq r7 r1 into r35;
    ternary r35 r32 r33 into r36;
    is.eq r9 r1 into r37;
    ternary r37 r32 r33 into r38;
    cast r36 r38 r15.last_k into r39 as Pair;
    set r39 into pairs[r14];
    cast r2 r5 into r40 as AccountKeyData;
    hash.bhp256 r40 into r41 as field;
    get.or_use account[r41] 0u128 into r42;
    add r42 r4 into r43;
    set r43 into account[r41];

function swap_private_for_exact_public:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as address.public;
    is.neq r0.token r1 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    sub r0.amount r2 into r8;
    cast r0.owner r0.token r8 into r9 as PrivateToken.record;
    async swap_private_for_exact_public r0.token r1 r2 r3 r4 r5 into r10;
    output r9 as PrivateToken.record;
    output r10 as alphaswap_v1.aleo/swap_private_for_exact_public.future;

finalize swap_private_for_exact_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as address.public;
    lt r0 r1 into r6;
    ternary r6 r0 r1 into r7;
    lt r0 r1 into r8;
    ternary r8 r1 r0 into r9;
    lt r7 r9 into r10;
    assert.eq r10 true ;
    cast r7 r9 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r12 into r13 as TokenIdData;
    hash.bhp256 r13 into r14 as field;
    get pairs[r14] into r15;
    is.eq r7 r0 into r16;
    ternary r16 r15.reserve_a r15.reserve_b into r17;
    is.eq r7 r1 into r18;
    ternary r18 r15.reserve_a r15.reserve_b into r19;
    mul r17 r3 into r20;
    mul r20 1000u128 into r21;
    sub r19 r3 into r22;
    mul r22 997u128 into r23;
    div r21 r23 into r24;
    add r24 1u128 into r25;
    lte r25 r2 into r26;
    assert.eq r26 true ;
    gt r25 0u128 into r27;
    assert.eq r27 true ;
    cast r0 r5 into r28 as AccountKeyData;
    hash.bhp256 r28 into r29 as field;
    sub r2 r25 into r30;
    get.or_use account[r29] 0u128 into r31;
    add r31 r30 into r32;
    set r32 into account[r29];
    add r17 r25 into r33;
    sub r19 r3 into r34;
    mul r33 r34 into r35;
    assert.neq r35 0u128 ;
    is.eq r7 r0 into r36;
    ternary r36 r33 r34 into r37;
    is.eq r9 r0 into r38;
    ternary r38 r33 r34 into r39;
    cast r37 r39 r15.last_k into r40 as Pair;
    set r40 into pairs[r14];
    cast r1 r4 into r41 as AccountKeyData;
    hash.bhp256 r41 into r42 as field;
    get.or_use account[r42] 0u128 into r43;
    add r43 r3 into r44;
    set r44 into account[r42];

function swap_private_for_exact_private:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.private;
    input r5 as address.public;
    is.neq r0.token r1 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    cast r4 r1 r3 into r8 as PrivateToken.record;
    sub r0.amount r2 into r9;
    cast r0.owner r0.token r9 into r10 as PrivateToken.record;
    async swap_private_for_exact_private r0.token r1 r2 r3 r5 into r11;
    output r8 as PrivateToken.record;
    output r10 as PrivateToken.record;
    output r11 as alphaswap_v1.aleo/swap_private_for_exact_private.future;

finalize swap_private_for_exact_private:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    ternary r5 r0 r1 into r6;
    lt r0 r1 into r7;
    ternary r7 r1 r0 into r8;
    lt r6 r8 into r9;
    assert.eq r9 true ;
    cast r6 r8 into r10 as PairKeyData;
    hash.bhp256 r10 into r11 as u128;
    cast aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf aleo17netm8w52pfdrlm86jan983kr98kur272yjqg8zhfqr8x746mq8qkcf8jf r11 into r12 as TokenIdData;
    hash.bhp256 r12 into r13 as field;
    get pairs[r13] into r14;
    is.eq r6 r0 into r15;
    ternary r15 r14.reserve_a r14.reserve_b into r16;
    is.eq r6 r1 into r17;
    ternary r17 r14.reserve_a r14.reserve_b into r18;
    mul r16 r3 into r19;
    mul r19 1000u128 into r20;
    sub r18 r3 into r21;
    mul r21 997u128 into r22;
    div r20 r22 into r23;
    add r23 1u128 into r24;
    lte r24 r2 into r25;
    assert.eq r25 true ;
    gt r24 0u128 into r26;
    assert.eq r26 true ;
    cast r0 r4 into r27 as AccountKeyData;
    hash.bhp256 r27 into r28 as field;
    sub r2 r24 into r29;
    get.or_use account[r28] 0u128 into r30;
    add r30 r29 into r31;
    set r31 into account[r28];
    add r16 r24 into r32;
    sub r18 r3 into r33;
    mul r32 r33 into r34;
    assert.neq r34 0u128 ;
    is.eq r6 r0 into r35;
    ternary r35 r32 r33 into r36;
    is.eq r8 r0 into r37;
    ternary r37 r32 r33 into r38;
    cast r36 r38 r14.last_k into r39 as Pair;
    set r39 into pairs[r13];
