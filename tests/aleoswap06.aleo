import credits.aleo;

program aleoswap06.aleo;

record PrivateToken:
    owner as address.private;
    token as field.private;
    amount as u128.private;

struct TokenInfo:
    name as field;
    symbol as field;
    decimals as u8;
    total_supply as u128;
    admin as address;

struct GlobalState:
    next_token_id as field;

struct BalanceKeyData:
    token as field;
    user as address;

struct AllowanceKeyData:
    token as field;
    payer as address;
    spender as address;

struct Pair:
    reserve_a as u128;
    reserve_b as u128;

struct PairKeyData:
    token_a as field;
    token_b as field;

mapping balances:
    key as field.public;
    value as u128.public;

mapping allowance:
    key as field.public;
    value as u128.public;

mapping tokens:
    key as field.public;
    value as TokenInfo.public;

mapping faucets:
    key as field.public;
    value as u128.public;

mapping global_state:
    key as boolean.public;
    value as GlobalState.public;

mapping pairs:
    key as field.public;
    value as Pair.public;

function create_token:
    input r0 as TokenInfo.public;
    gt r0.name 0field into r1;
    assert.eq r1 true ;
    async create_token r0 self.caller into r2;
    output r2 as aleoswap06.aleo/create_token.future;

finalize create_token:
    input r0 as TokenInfo.public;
    input r1 as address.public;
    get global_state[true] into r2;
    add r2.next_token_id 1field into r3;
    cast r3 into r4 as GlobalState;
    set r4 into global_state[true];
    set r0 into tokens[r2.next_token_id];
    cast r2.next_token_id r1 into r5 as BalanceKeyData;
    hash.bhp256 r5 into r6 as field;
    set r0.total_supply into balances[r6];

function transfer:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async transfer r0 self.caller r1 r2 into r3;
    output r3 as aleoswap06.aleo/transfer.future;

finalize transfer:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    contains tokens[r0] into r4;
    assert.eq r4 true ;
    cast r0 r1 into r5 as BalanceKeyData;
    hash.bhp256 r5 into r6 as field;
    get balances[r6] into r7;
    sub r7 r3 into r8;
    set r8 into balances[r6];
    cast r0 r2 into r9 as BalanceKeyData;
    hash.bhp256 r9 into r10 as field;
    get.or_use balances[r10] 0u128 into r11;
    add r11 r3 into r12;
    set r12 into balances[r10];

function approve:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    async approve r0 self.caller r1 r2 into r3;
    output r3 as aleoswap06.aleo/approve.future;

finalize approve:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    contains tokens[r0] into r4;
    assert.eq r4 true ;
    cast r0 r1 r2 into r5 as AllowanceKeyData;
    hash.bhp256 r5 into r6 as field;
    set r3 into allowance[r6];

function transfer_from:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as address.public;
    input r3 as u128.public;
    async transfer_from self.caller r0 r1 r2 r3 into r4;
    output r4 as aleoswap06.aleo/transfer_from.future;

finalize transfer_from:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    input r3 as address.public;
    input r4 as u128.public;
    contains tokens[r1] into r5;
    assert.eq r5 true ;
    cast r1 r2 r0 into r6 as AllowanceKeyData;
    hash.bhp256 r6 into r7 as field;
    get allowance[r7] into r8;
    sub r8 r4 into r9;
    set r9 into allowance[r7];
    cast r1 r2 into r10 as BalanceKeyData;
    hash.bhp256 r10 into r11 as field;
    get balances[r11] into r12;
    sub r12 r4 into r13;
    set r13 into balances[r11];
    cast r1 r3 into r14 as BalanceKeyData;
    hash.bhp256 r14 into r15 as field;
    get.or_use balances[r15] 0u128 into r16;
    add r16 r4 into r17;
    set r17 into balances[r15];

function set_token_faucet:
    input r0 as field.public;
    input r1 as u128.public;
    is.neq r0 0field into r2;
    assert.eq r2 true ;
    async set_token_faucet self.caller r0 r1 into r3;
    output r3 as aleoswap06.aleo/set_token_faucet.future;

finalize set_token_faucet:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as u128.public;
    get tokens[r1] into r3;
    assert.eq r0 r3.admin ;
    set r2 into faucets[r1];

function change_token_admin:
    input r0 as field.public;
    input r1 as address.public;
    async change_token_admin self.caller r0 r1 into r2;
    output r2 as aleoswap06.aleo/change_token_admin.future;

finalize change_token_admin:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as address.public;
    get tokens[r1] into r3;
    assert.eq r0 r3.admin ;
    cast r3.name r3.symbol r3.decimals r3.total_supply r2 into r4 as TokenInfo;
    set r4 into tokens[r1];

function token_faucet:
    input r0 as field.public;
    input r1 as address.public;
    async token_faucet r0 r1 into r2;
    output r2 as aleoswap06.aleo/token_faucet.future;

finalize token_faucet:
    input r0 as field.public;
    input r1 as address.public;
    get faucets[r0] into r2;
    gt r2 0u128 into r3;
    assert.eq r3 true ;
    get tokens[r0] into r4;
    add r4.total_supply r2 into r5;
    cast r4.name r4.symbol r4.decimals r5 r4.admin into r6 as TokenInfo;
    set r6 into tokens[r0];
    cast r0 r1 into r7 as BalanceKeyData;
    hash.bhp256 r7 into r8 as field;
    get.or_use balances[r8] 0u128 into r9;
    add r9 r2 into r10;
    set r10 into balances[r8];

function wrap_private_credits:
    input r0 as credits.aleo/credits.record;
    input r1 as address.public;
    input r2 as u64.public;
    call credits.aleo/transfer_private_to_public r0 aleo1n0rhgnc0xnc7n0quksssd2zc5u0us2p6hu09mclyq6ay2ggthqzqkmmklf r2 into r3 r4;
    cast r2 into r5 as u128;
    async wrap_private_credits r4 r1 r5 into r6;
    output r3 as credits.aleo/credits.record;
    output r6 as aleoswap06.aleo/wrap_private_credits.future;

finalize wrap_private_credits:
    input r0 as credits.aleo/transfer_private_to_public.future;
    input r1 as address.public;
    input r2 as u128.public;
    await r0;
    get tokens[0field] into r3;
    add r3.total_supply r2 into r4;
    cast r3.name r3.symbol r3.decimals r4 r3.admin into r5 as TokenInfo;
    set r5 into tokens[0field];
    cast 0field r1 into r6 as BalanceKeyData;
    hash.bhp256 r6 into r7 as field;
    get.or_use balances[r7] 0u128 into r8;
    add r8 r2 into r9;
    set r9 into balances[r7];

function unwrap_to_public:
    input r0 as address.public;
    input r1 as u64.public;
    gt r1 0u64 into r2;
    assert.eq r2 true ;
    call credits.aleo/transfer_public r0 r1 into r3;
    cast r1 into r4 as u128;
    async unwrap_to_public r3 self.caller r4 into r5;
    output r5 as aleoswap06.aleo/unwrap_to_public.future;

finalize unwrap_to_public:
    input r0 as credits.aleo/transfer_public.future;
    input r1 as address.public;
    input r2 as u128.public;
    await r0;
    get tokens[0field] into r3;
    sub r3.total_supply r2 into r4;
    cast r3.name r3.symbol r3.decimals r4 r3.admin into r5 as TokenInfo;
    set r5 into tokens[0field];
    cast 0field r1 into r6 as BalanceKeyData;
    hash.bhp256 r6 into r7 as field;
    get.or_use balances[r7] 0u128 into r8;
    sub r8 r2 into r9;
    set r9 into balances[r7];

function unwrap_to_private:
    input r0 as address.private;
    input r1 as u64.public;
    gt r1 0u64 into r2;
    assert.eq r2 true ;
    call credits.aleo/transfer_public_to_private r0 r1 into r3 r4;
    cast r1 into r5 as u128;
    async unwrap_to_private r4 self.caller r5 into r6;
    output r3 as credits.aleo/credits.record;
    output r6 as aleoswap06.aleo/unwrap_to_private.future;

finalize unwrap_to_private:
    input r0 as credits.aleo/transfer_public_to_private.future;
    input r1 as address.public;
    input r2 as u128.public;
    await r0;
    get tokens[0field] into r3;
    sub r3.total_supply r2 into r4;
    cast r3.name r3.symbol r3.decimals r4 r3.admin into r5 as TokenInfo;
    set r5 into tokens[0field];
    cast 0field r1 into r6 as BalanceKeyData;
    hash.bhp256 r6 into r7 as field;
    get.or_use balances[r7] 0u128 into r8;
    sub r8 r2 into r9;
    set r9 into balances[r7];

function init:
    assert.eq self.caller aleo1tdszx3hcgnyp2jw3y3fzvw27vremxcs24u4pys6vptg9y2jfsvps8e8ffz ;
    async init into r0;
    output r0 as aleoswap06.aleo/init.future;

finalize init:
    cast 0field into r0 as GlobalState;
    get.or_use global_state[true] r0 into r1;
    assert.eq r1.next_token_id 0field ;
    cast 1field into r2 as GlobalState;
    set r2 into global_state[true];
    cast 105716693521782238488585583field 374757672271field 6u8 0u128 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r3 as TokenInfo;
    set r3 into tokens[0field];

function transfer_to_private:
    input r0 as field.public;
    input r1 as address.private;
    input r2 as u128.public;
    cast r1 r0 r2 into r3 as PrivateToken.record;
    hash.bhp256 r3 into r4 as field;
    async transfer_to_private r0 self.caller r2 into r5;
    output r3 as PrivateToken.record;
    output r5 as aleoswap06.aleo/transfer_to_private.future;

finalize transfer_to_private:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true ;
    cast r0 r1 into r4 as BalanceKeyData;
    hash.bhp256 r4 into r5 as field;
    get balances[r5] into r6;
    sub r6 r2 into r7;
    set r7 into balances[r5];

function transfer_to_public:
    input r0 as PrivateToken.record;
    input r1 as address.public;
    input r2 as u128.public;
    sub r0.amount r2 into r3;
    cast r0.owner r0.token r3 into r4 as PrivateToken.record;
    async transfer_to_public r0.token r1 r2 into r5;
    output r4 as PrivateToken.record;
    output r5 as aleoswap06.aleo/transfer_to_public.future;

finalize transfer_to_public:
    input r0 as field.public;
    input r1 as address.public;
    input r2 as u128.public;
    contains tokens[r0] into r3;
    assert.eq r3 true ;
    cast r0 r1 into r4 as BalanceKeyData;
    hash.bhp256 r4 into r5 as field;
    get.or_use balances[r5] 0u128 into r6;
    add r6 r2 into r7;
    set r7 into balances[r5];

function transfer_privately:
    input r0 as PrivateToken.record;
    input r1 as address.private;
    input r2 as u128.private;
    cast r1 r0.token r2 into r3 as PrivateToken.record;
    sub r0.amount r2 into r4;
    cast r0.owner r0.token r4 into r5 as PrivateToken.record;
    output r3 as PrivateToken.record;
    output r5 as PrivateToken.record;

function join:
    input r0 as PrivateToken.record;
    input r1 as PrivateToken.record;
    assert.eq r0.token r1.token ;
    add r0.amount r1.amount into r2;
    cast r0.owner r0.token r2 into r3 as PrivateToken.record;
    output r3 as PrivateToken.record;

function create_pair:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    async create_pair self.caller r0 r1 r2 r3 r4 into r8;
    output r8 as aleoswap06.aleo/create_pair.future;

finalize create_pair:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r1 r2 into r6;
    assert.eq r6 true ;
    cast r1 r2 into r7 as PairKeyData;
    hash.bhp256 r7 into r8 as field;
    mul r3 r4 into r9;
    is.eq r9 0u128 into r10;
    shr r9 64u32 into r11;
    gt r11 0u128 into r12;
    shr r9 64u32 into r13;
    add 0u32 64u32 into r14;
    ternary r12 r13 r9 into r15;
    ternary r12 r14 0u32 into r16;
    shr r15 32u32 into r17;
    gt r17 0u128 into r18;
    shr r15 32u32 into r19;
    add r16 32u32 into r20;
    ternary r18 r19 r15 into r21;
    ternary r18 r20 r16 into r22;
    shr r21 16u32 into r23;
    gt r23 0u128 into r24;
    shr r21 16u32 into r25;
    add r22 16u32 into r26;
    ternary r24 r25 r21 into r27;
    ternary r24 r26 r22 into r28;
    shr r27 8u32 into r29;
    gt r29 0u128 into r30;
    shr r27 8u32 into r31;
    add r28 8u32 into r32;
    ternary r30 r31 r27 into r33;
    ternary r30 r32 r28 into r34;
    shr r33 4u32 into r35;
    gt r35 0u128 into r36;
    shr r33 4u32 into r37;
    add r34 4u32 into r38;
    ternary r36 r37 r33 into r39;
    ternary r36 r38 r34 into r40;
    shr r39 2u32 into r41;
    gt r41 0u128 into r42;
    shr r39 2u32 into r43;
    add r40 2u32 into r44;
    ternary r42 r43 r39 into r45;
    ternary r42 r44 r40 into r46;
    shr r45 1u32 into r47;
    gt r47 0u128 into r48;
    add r46 1u32 into r49;
    ternary r48 r49 r46 into r50;
    div r50 2u32 into r51;
    shl 1u128 r51 into r52;
    div r9 r52 into r53;
    add r52 r53 into r54;
    shr r54 1u32 into r55;
    div r9 r55 into r56;
    add r55 r56 into r57;
    shr r57 1u32 into r58;
    div r9 r58 into r59;
    add r58 r59 into r60;
    shr r60 1u32 into r61;
    div r9 r61 into r62;
    add r61 r62 into r63;
    shr r63 1u32 into r64;
    div r9 r64 into r65;
    add r64 r65 into r66;
    shr r66 1u32 into r67;
    div r9 r67 into r68;
    add r67 r68 into r69;
    shr r69 1u32 into r70;
    div r9 r70 into r71;
    add r70 r71 into r72;
    shr r72 1u32 into r73;
    div r9 r73 into r74;
    lt r73 r74 into r75;
    ternary r75 r73 r74 into r76;
    ternary r10 0u128 r76 into r77;
    gt r77 0u128 into r78;
    assert.eq r78 true ;
    cast 5183377571718029925300968712562field 4281168field 6u8 0u128 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r79 as TokenInfo;
    get.or_use tokens[r8] r79 into r80;
    assert.eq r80.total_supply 0u128 ;
    cast 0u128 0u128 into r81 as Pair;
    get.or_use pairs[r8] r81 into r82;
    cast r1 r0 into r83 as BalanceKeyData;
    hash.bhp256 r83 into r84 as field;
    get balances[r84] into r85;
    sub r85 r3 into r86;
    set r86 into balances[r84];
    cast r2 r0 into r87 as BalanceKeyData;
    hash.bhp256 r87 into r88 as field;
    get balances[r88] into r89;
    sub r89 r4 into r90;
    set r90 into balances[r88];
    cast r8 r5 into r91 as BalanceKeyData;
    hash.bhp256 r91 into r92 as field;
    get.or_use balances[r92] 0u128 into r93;
    add r93 r77 into r94;
    set r94 into balances[r92];
    add r80.total_supply r77 into r95;
    cast r80.name r80.symbol r80.decimals r95 r80.admin into r96 as TokenInfo;
    set r96 into tokens[r8];
    add r82.reserve_a r3 into r97;
    add r82.reserve_b r4 into r98;
    cast r97 r98 into r99 as Pair;
    set r99 into pairs[r8];

function create_pair_privately:
    input r0 as PrivateToken.record;
    input r1 as PrivateToken.record;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.private;
    input r5 as u128.public;
    lt r0.token r1.token into r6;
    assert.eq r6 true ;
    gt r2 0u128 into r7;
    assert.eq r7 true ;
    gt r3 0u128 into r8;
    assert.eq r8 true ;
    gt r5 0u128 into r9;
    assert.eq r9 true ;
    sub r0.amount r2 into r10;
    cast r0.owner r0.token r10 into r11 as PrivateToken.record;
    sub r1.amount r3 into r12;
    cast r1.owner r1.token r12 into r13 as PrivateToken.record;
    lt r0.token r1.token into r14;
    assert.eq r14 true ;
    cast r0.token r1.token into r15 as PairKeyData;
    hash.bhp256 r15 into r16 as field;
    cast r4 r16 r5 into r17 as PrivateToken.record;
    async create_pair_privately r0.token r1.token r2 r3 r16 r5 into r18;
    output r17 as PrivateToken.record;
    output r11 as PrivateToken.record;
    output r13 as PrivateToken.record;
    output r18 as aleoswap06.aleo/create_pair_privately.future;

finalize create_pair_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as field.public;
    input r5 as u128.public;
    mul r2 r3 into r6;
    is.eq r6 0u128 into r7;
    shr r6 64u32 into r8;
    gt r8 0u128 into r9;
    shr r6 64u32 into r10;
    add 0u32 64u32 into r11;
    ternary r9 r10 r6 into r12;
    ternary r9 r11 0u32 into r13;
    shr r12 32u32 into r14;
    gt r14 0u128 into r15;
    shr r12 32u32 into r16;
    add r13 32u32 into r17;
    ternary r15 r16 r12 into r18;
    ternary r15 r17 r13 into r19;
    shr r18 16u32 into r20;
    gt r20 0u128 into r21;
    shr r18 16u32 into r22;
    add r19 16u32 into r23;
    ternary r21 r22 r18 into r24;
    ternary r21 r23 r19 into r25;
    shr r24 8u32 into r26;
    gt r26 0u128 into r27;
    shr r24 8u32 into r28;
    add r25 8u32 into r29;
    ternary r27 r28 r24 into r30;
    ternary r27 r29 r25 into r31;
    shr r30 4u32 into r32;
    gt r32 0u128 into r33;
    shr r30 4u32 into r34;
    add r31 4u32 into r35;
    ternary r33 r34 r30 into r36;
    ternary r33 r35 r31 into r37;
    shr r36 2u32 into r38;
    gt r38 0u128 into r39;
    shr r36 2u32 into r40;
    add r37 2u32 into r41;
    ternary r39 r40 r36 into r42;
    ternary r39 r41 r37 into r43;
    shr r42 1u32 into r44;
    gt r44 0u128 into r45;
    add r43 1u32 into r46;
    ternary r45 r46 r43 into r47;
    div r47 2u32 into r48;
    shl 1u128 r48 into r49;
    div r6 r49 into r50;
    add r49 r50 into r51;
    shr r51 1u32 into r52;
    div r6 r52 into r53;
    add r52 r53 into r54;
    shr r54 1u32 into r55;
    div r6 r55 into r56;
    add r55 r56 into r57;
    shr r57 1u32 into r58;
    div r6 r58 into r59;
    add r58 r59 into r60;
    shr r60 1u32 into r61;
    div r6 r61 into r62;
    add r61 r62 into r63;
    shr r63 1u32 into r64;
    div r6 r64 into r65;
    add r64 r65 into r66;
    shr r66 1u32 into r67;
    div r6 r67 into r68;
    add r67 r68 into r69;
    shr r69 1u32 into r70;
    div r6 r70 into r71;
    lt r70 r71 into r72;
    ternary r72 r70 r71 into r73;
    ternary r7 0u128 r73 into r74;
    is.eq r5 r74 into r75;
    assert.eq r75 true ;
    cast 5183377571718029925300968712562field 4281168field 6u8 0u128 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r76 as TokenInfo;
    get.or_use tokens[r4] r76 into r77;
    assert.eq r77.total_supply 0u128 ;
    cast 0u128 0u128 into r78 as Pair;
    get.or_use pairs[r4] r78 into r79;
    add r77.total_supply r74 into r80;
    cast r77.name r77.symbol r77.decimals r80 r77.admin into r81 as TokenInfo;
    set r81 into tokens[r4];
    add r79.reserve_a r2 into r82;
    add r79.reserve_b r3 into r83;
    cast r82 r83 into r84 as Pair;
    set r84 into pairs[r4];

function add_liquidity:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.public;
    lt r0 r1 into r7;
    assert.eq r7 true ;
    gt r2 0u128 into r8;
    gte r2 r4 into r9;
    and r8 r9 into r10;
    assert.eq r10 true ;
    gt r3 0u128 into r11;
    gte r3 r5 into r12;
    and r11 r12 into r13;
    assert.eq r13 true ;
    async add_liquidity self.caller r0 r1 r2 r3 r4 r5 r6 into r14;
    output r14 as aleoswap06.aleo/add_liquidity.future;

finalize add_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as u128.public;
    input r7 as address.public;
    lt r1 r2 into r8;
    assert.eq r8 true ;
    cast r1 r2 into r9 as PairKeyData;
    hash.bhp256 r9 into r10 as field;
    get pairs[r10] into r11;
    get tokens[r10] into r12;
    mul r3 r12.total_supply into r13;
    div r13 r11.reserve_a into r14;
    mul r4 r12.total_supply into r15;
    div r15 r11.reserve_b into r16;
    lte r14 r16 into r17;
    ternary r17 r14 r16 into r18;
    lte r14 r18 into r19;
    mul r18 r11.reserve_a into r20;
    add r20 r12.total_supply into r21;
    sub r21 1u128 into r22;
    div r22 r12.total_supply into r23;
    ternary r19 r3 r23 into r24;
    lte r16 r18 into r25;
    mul r18 r11.reserve_b into r26;
    add r26 r12.total_supply into r27;
    sub r27 1u128 into r28;
    div r28 r12.total_supply into r29;
    ternary r25 r4 r29 into r30;
    gt r18 0u128 into r31;
    assert.eq r31 true ;
    gte r24 r5 into r32;
    assert.eq r32 true ;
    gte r30 r6 into r33;
    assert.eq r33 true ;
    cast r1 r0 into r34 as BalanceKeyData;
    hash.bhp256 r34 into r35 as field;
    get balances[r35] into r36;
    sub r36 r24 into r37;
    set r37 into balances[r35];
    cast r2 r0 into r38 as BalanceKeyData;
    hash.bhp256 r38 into r39 as field;
    get balances[r39] into r40;
    sub r40 r30 into r41;
    set r41 into balances[r39];
    cast r10 r7 into r42 as BalanceKeyData;
    hash.bhp256 r42 into r43 as field;
    get.or_use balances[r43] 0u128 into r44;
    add r44 r18 into r45;
    set r45 into balances[r43];
    add r12.total_supply r18 into r46;
    cast r12.name r12.symbol r12.decimals r46 r12.admin into r47 as TokenInfo;
    set r47 into tokens[r10];
    add r11.reserve_a r24 into r48;
    add r11.reserve_b r30 into r49;
    cast r48 r49 into r50 as Pair;
    set r50 into pairs[r10];

function add_liquidity_privately:
    input r0 as PrivateToken.record;
    input r1 as PrivateToken.record;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as u128.public;
    input r7 as address.private;
    input r8 as address.public;
    lt r0.token r1.token into r9;
    assert.eq r9 true ;
    gt r2 0u128 into r10;
    gte r2 r4 into r11;
    and r10 r11 into r12;
    assert.eq r12 true ;
    gt r3 0u128 into r13;
    gte r3 r5 into r14;
    and r13 r14 into r15;
    assert.eq r15 true ;
    gt r6 0u128 into r16;
    assert.eq r16 true ;
    sub r0.amount r2 into r17;
    cast r0.owner r0.token r17 into r18 as PrivateToken.record;
    sub r1.amount r3 into r19;
    cast r1.owner r1.token r19 into r20 as PrivateToken.record;
    lt r0.token r1.token into r21;
    assert.eq r21 true ;
    cast r0.token r1.token into r22 as PairKeyData;
    hash.bhp256 r22 into r23 as field;
    cast r7 r23 r6 into r24 as PrivateToken.record;
    async add_liquidity_privately r0.token r1.token r23 r2 r3 r4 r5 r6 r8 into r25;
    output r24 as PrivateToken.record;
    output r18 as PrivateToken.record;
    output r20 as PrivateToken.record;
    output r25 as aleoswap06.aleo/add_liquidity_privately.future;

finalize add_liquidity_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as u128.public;
    input r7 as u128.public;
    input r8 as address.public;
    get pairs[r2] into r9;
    get tokens[r2] into r10;
    mul r3 r10.total_supply into r11;
    div r11 r9.reserve_a into r12;
    mul r4 r10.total_supply into r13;
    div r13 r9.reserve_b into r14;
    lte r12 r14 into r15;
    ternary r15 r12 r14 into r16;
    lte r12 r16 into r17;
    mul r16 r9.reserve_a into r18;
    add r18 r10.total_supply into r19;
    sub r19 1u128 into r20;
    div r20 r10.total_supply into r21;
    ternary r17 r3 r21 into r22;
    lte r14 r16 into r23;
    mul r16 r9.reserve_b into r24;
    add r24 r10.total_supply into r25;
    sub r25 1u128 into r26;
    div r26 r10.total_supply into r27;
    ternary r23 r4 r27 into r28;
    gte r16 r7 into r29;
    assert.eq r29 true ;
    gte r3 r22 into r30;
    gte r22 r5 into r31;
    and r30 r31 into r32;
    assert.eq r32 true ;
    gte r4 r28 into r33;
    gte r28 r6 into r34;
    and r33 r34 into r35;
    assert.eq r35 true ;
    cast r0 r8 into r36 as BalanceKeyData;
    hash.bhp256 r36 into r37 as field;
    get.or_use balances[r37] 0u128 into r38;
    add r38 r3 into r39;
    sub r39 r22 into r40;
    set r40 into balances[r37];
    cast r1 r8 into r41 as BalanceKeyData;
    hash.bhp256 r41 into r42 as field;
    get.or_use balances[r42] 0u128 into r43;
    add r43 r4 into r44;
    sub r44 r28 into r45;
    set r45 into balances[r42];
    cast r2 r8 into r46 as BalanceKeyData;
    hash.bhp256 r46 into r47 as field;
    get.or_use balances[r47] 0u128 into r48;
    add r48 r16 into r49;
    sub r49 r7 into r50;
    set r50 into balances[r47];
    add r10.total_supply r16 into r51;
    cast r10.name r10.symbol r10.decimals r51 r10.admin into r52 as TokenInfo;
    set r52 into tokens[r2];
    add r9.reserve_a r22 into r53;
    add r9.reserve_b r28 into r54;
    cast r53 r54 into r55 as Pair;
    set r55 into pairs[r2];

function remove_liquidity:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r0 r1 into r6;
    assert.eq r6 true ;
    gt r2 0u128 into r7;
    assert.eq r7 true ;
    async remove_liquidity self.caller r0 r1 r2 r3 r4 r5 into r8;
    output r8 as aleoswap06.aleo/remove_liquidity.future;

finalize remove_liquidity:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.public;
    lt r1 r2 into r7;
    assert.eq r7 true ;
    cast r1 r2 into r8 as PairKeyData;
    hash.bhp256 r8 into r9 as field;
    get tokens[r9] into r10;
    get pairs[r9] into r11;
    mul r3 r11.reserve_a into r12;
    div r12 r10.total_supply into r13;
    mul r3 r11.reserve_b into r14;
    div r14 r10.total_supply into r15;
    gte r13 r4 into r16;
    gte r15 r5 into r17;
    and r16 r17 into r18;
    assert.eq r18 true ;
    gt r13 0u128 into r19;
    gt r15 0u128 into r20;
    or r19 r20 into r21;
    assert.eq r21 true ;
    cast r9 r0 into r22 as BalanceKeyData;
    hash.bhp256 r22 into r23 as field;
    get balances[r23] into r24;
    sub r24 r3 into r25;
    set r25 into balances[r23];
    sub r10.total_supply r3 into r26;
    cast r10.name r10.symbol r10.decimals r26 r10.admin into r27 as TokenInfo;
    set r27 into tokens[r9];
    sub r11.reserve_a r13 into r28;
    sub r11.reserve_b r15 into r29;
    cast r28 r29 into r30 as Pair;
    set r30 into pairs[r9];
    cast r1 r6 into r31 as BalanceKeyData;
    hash.bhp256 r31 into r32 as field;
    cast r2 r6 into r33 as BalanceKeyData;
    hash.bhp256 r33 into r34 as field;
    get.or_use balances[r32] 0u128 into r35;
    add r35 r13 into r36;
    set r36 into balances[r32];
    get.or_use balances[r34] 0u128 into r37;
    add r37 r15 into r38;
    set r38 into balances[r34];

function remove_liquidity_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as PrivateToken.record;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.private;
    input r7 as address.public;
    lt r0 r1 into r8;
    assert.eq r8 true ;
    gt r3 0u128 into r9;
    assert.eq r9 true ;
    lt r0 r1 into r10;
    assert.eq r10 true ;
    cast r0 r1 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as field;
    assert.eq r12 r2.token ;
    cast r6 r0 r4 into r13 as PrivateToken.record;
    cast r6 r1 r5 into r14 as PrivateToken.record;
    sub r2.amount r3 into r15;
    cast r2.owner r12 r15 into r16 as PrivateToken.record;
    async remove_liquidity_privately r0 r1 r12 r3 r4 r5 r7 into r17;
    output r13 as PrivateToken.record;
    output r14 as PrivateToken.record;
    output r16 as PrivateToken.record;
    output r17 as aleoswap06.aleo/remove_liquidity_privately.future;

finalize remove_liquidity_privately:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as u128.public;
    input r6 as address.public;
    get tokens[r2] into r7;
    get pairs[r2] into r8;
    mul r3 r8.reserve_a into r9;
    div r9 r7.total_supply into r10;
    mul r3 r8.reserve_b into r11;
    div r11 r7.total_supply into r12;
    gte r10 r4 into r13;
    gte r12 r5 into r14;
    and r13 r14 into r15;
    assert.eq r15 true ;
    gt r10 0u128 into r16;
    gt r12 0u128 into r17;
    or r16 r17 into r18;
    assert.eq r18 true ;
    sub r7.total_supply r3 into r19;
    cast r7.name r7.symbol r7.decimals r19 r7.admin into r20 as TokenInfo;
    set r20 into tokens[r2];
    sub r8.reserve_a r10 into r21;
    sub r8.reserve_b r12 into r22;
    cast r21 r22 into r23 as Pair;
    set r23 into pairs[r2];
    cast r0 r6 into r24 as BalanceKeyData;
    hash.bhp256 r24 into r25 as field;
    cast r1 r6 into r26 as BalanceKeyData;
    hash.bhp256 r26 into r27 as field;
    get.or_use balances[r25] 0u128 into r28;
    add r28 r10 into r29;
    sub r29 r4 into r30;
    set r30 into balances[r25];
    get.or_use balances[r27] 0u128 into r31;
    add r31 r12 into r32;
    sub r32 r5 into r33;
    set r33 into balances[r27];

function swap_exact_tokens_for_tokens:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0 r1 into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    async swap_exact_tokens_for_tokens self.caller r0 r1 r2 r3 r4 into r7;
    output r7 as aleoswap06.aleo/swap_exact_tokens_for_tokens.future;

finalize swap_exact_tokens_for_tokens:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r1 r2 into r6;
    ternary r6 r1 r2 into r7;
    lt r1 r2 into r8;
    ternary r8 r2 r1 into r9;
    lt r7 r9 into r10;
    assert.eq r10 true ;
    cast r7 r9 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as field;
    get pairs[r12] into r13;
    is.eq r7 r1 into r14;
    ternary r14 r13.reserve_a r13.reserve_b into r15;
    is.eq r7 r2 into r16;
    ternary r16 r13.reserve_a r13.reserve_b into r17;
    mul r3 997u128 into r18;
    mul r18 r17 into r19;
    mul r15 1000u128 into r20;
    add r20 r18 into r21;
    div r19 r21 into r22;
    gte r22 r4 into r23;
    assert.eq r23 true ;
    gt r22 0u128 into r24;
    assert.eq r24 true ;
    cast r1 r0 into r25 as BalanceKeyData;
    hash.bhp256 r25 into r26 as field;
    get balances[r26] into r27;
    sub r27 r3 into r28;
    set r28 into balances[r26];
    add r15 r3 into r29;
    sub r17 r22 into r30;
    is.eq r7 r1 into r31;
    ternary r31 r29 r30 into r32;
    is.eq r9 r1 into r33;
    ternary r33 r29 r30 into r34;
    cast r32 r34 into r35 as Pair;
    set r35 into pairs[r12];
    cast r2 r5 into r36 as BalanceKeyData;
    hash.bhp256 r36 into r37 as field;
    get.or_use balances[r37] 0u128 into r38;
    add r38 r22 into r39;
    set r39 into balances[r37];

function swap_exact_private_for_public:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0.token r1 into r5;
    assert.eq r5 true ;
    gt r2 0u128 into r6;
    assert.eq r6 true ;
    sub r0.amount r2 into r7;
    cast r0.owner r0.token r7 into r8 as PrivateToken.record;
    async swap_exact_private_for_public r0.token r1 r2 r3 r4 into r9;
    output r8 as PrivateToken.record;
    output r9 as aleoswap06.aleo/swap_exact_private_for_public.future;

finalize swap_exact_private_for_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    ternary r5 r0 r1 into r6;
    lt r0 r1 into r7;
    ternary r7 r1 r0 into r8;
    lt r6 r8 into r9;
    assert.eq r9 true ;
    cast r6 r8 into r10 as PairKeyData;
    hash.bhp256 r10 into r11 as field;
    get pairs[r11] into r12;
    is.eq r6 r0 into r13;
    ternary r13 r12.reserve_a r12.reserve_b into r14;
    is.eq r6 r1 into r15;
    ternary r15 r12.reserve_a r12.reserve_b into r16;
    mul r2 997u128 into r17;
    mul r17 r16 into r18;
    mul r14 1000u128 into r19;
    add r19 r17 into r20;
    div r18 r20 into r21;
    gte r21 r3 into r22;
    assert.eq r22 true ;
    gt r21 0u128 into r23;
    assert.eq r23 true ;
    add r14 r2 into r24;
    sub r16 r21 into r25;
    is.eq r6 r0 into r26;
    ternary r26 r24 r25 into r27;
    is.eq r8 r0 into r28;
    ternary r28 r24 r25 into r29;
    cast r27 r29 into r30 as Pair;
    set r30 into pairs[r11];
    cast r1 r4 into r31 as BalanceKeyData;
    hash.bhp256 r31 into r32 as field;
    get.or_use balances[r32] 0u128 into r33;
    add r33 r21 into r34;
    set r34 into balances[r32];

function swap_exact_private_for_private:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.private;
    input r5 as address.public;
    is.neq r0.token r1 into r6;
    assert.eq r6 true ;
    gt r2 0u128 into r7;
    assert.eq r7 true ;
    cast r4 r1 r3 into r8 as PrivateToken.record;
    sub r0.amount r2 into r9;
    cast r0.owner r0.token r9 into r10 as PrivateToken.record;
    async swap_exact_private_for_private r0.token r1 r2 r3 r5 into r11;
    output r8 as PrivateToken.record;
    output r10 as PrivateToken.record;
    output r11 as aleoswap06.aleo/swap_exact_private_for_private.future;

finalize swap_exact_private_for_private:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    ternary r5 r0 r1 into r6;
    lt r0 r1 into r7;
    ternary r7 r1 r0 into r8;
    lt r6 r8 into r9;
    assert.eq r9 true ;
    cast r6 r8 into r10 as PairKeyData;
    hash.bhp256 r10 into r11 as field;
    get pairs[r11] into r12;
    is.eq r6 r0 into r13;
    ternary r13 r12.reserve_a r12.reserve_b into r14;
    is.eq r6 r1 into r15;
    ternary r15 r12.reserve_a r12.reserve_b into r16;
    mul r2 997u128 into r17;
    mul r17 r16 into r18;
    mul r14 1000u128 into r19;
    add r19 r17 into r20;
    div r18 r20 into r21;
    gte r21 r3 into r22;
    assert.eq r22 true ;
    gt r21 0u128 into r23;
    assert.eq r23 true ;
    add r14 r2 into r24;
    sub r16 r21 into r25;
    is.eq r6 r0 into r26;
    ternary r26 r24 r25 into r27;
    is.eq r8 r0 into r28;
    ternary r28 r24 r25 into r29;
    cast r27 r29 into r30 as Pair;
    set r30 into pairs[r11];
    cast r1 r4 into r31 as BalanceKeyData;
    hash.bhp256 r31 into r32 as field;
    sub r21 r3 into r33;
    get.or_use balances[r32] 0u128 into r34;
    add r34 r33 into r35;
    set r35 into balances[r32];

function swap_tokens_for_exact_tokens:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    is.neq r0 r1 into r5;
    assert.eq r5 true ;
    gt r3 0u128 into r6;
    assert.eq r6 true ;
    async swap_tokens_for_exact_tokens self.caller r0 r1 r2 r3 r4 into r7;
    output r7 as aleoswap06.aleo/swap_tokens_for_exact_tokens.future;

finalize swap_tokens_for_exact_tokens:
    input r0 as address.public;
    input r1 as field.public;
    input r2 as field.public;
    input r3 as u128.public;
    input r4 as u128.public;
    input r5 as address.public;
    lt r1 r2 into r6;
    ternary r6 r1 r2 into r7;
    lt r1 r2 into r8;
    ternary r8 r2 r1 into r9;
    lt r7 r9 into r10;
    assert.eq r10 true ;
    cast r7 r9 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as field;
    get pairs[r12] into r13;
    is.eq r7 r1 into r14;
    ternary r14 r13.reserve_a r13.reserve_b into r15;
    is.eq r7 r2 into r16;
    ternary r16 r13.reserve_a r13.reserve_b into r17;
    mul r15 r4 into r18;
    mul r18 1000u128 into r19;
    sub r17 r4 into r20;
    mul r20 997u128 into r21;
    div r19 r21 into r22;
    add r22 1u128 into r23;
    lte r23 r3 into r24;
    assert.eq r24 true ;
    gt r23 0u128 into r25;
    assert.eq r25 true ;
    cast r1 r0 into r26 as BalanceKeyData;
    hash.bhp256 r26 into r27 as field;
    get balances[r27] into r28;
    sub r28 r23 into r29;
    set r29 into balances[r27];
    add r15 r23 into r30;
    sub r17 r4 into r31;
    is.eq r7 r1 into r32;
    ternary r32 r30 r31 into r33;
    is.eq r9 r1 into r34;
    ternary r34 r30 r31 into r35;
    cast r33 r35 into r36 as Pair;
    set r36 into pairs[r12];
    cast r2 r5 into r37 as BalanceKeyData;
    hash.bhp256 r37 into r38 as field;
    get.or_use balances[r38] 0u128 into r39;
    add r39 r4 into r40;
    set r40 into balances[r38];

function swap_private_for_exact_public:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as address.public;
    is.neq r0.token r1 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    sub r0.amount r2 into r8;
    cast r0.owner r0.token r8 into r9 as PrivateToken.record;
    async swap_private_for_exact_public r0.token r1 r2 r3 r4 r5 into r10;
    output r9 as PrivateToken.record;
    output r10 as aleoswap06.aleo/swap_private_for_exact_public.future;

finalize swap_private_for_exact_public:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    input r5 as address.public;
    lt r0 r1 into r6;
    ternary r6 r0 r1 into r7;
    lt r0 r1 into r8;
    ternary r8 r1 r0 into r9;
    lt r7 r9 into r10;
    assert.eq r10 true ;
    cast r7 r9 into r11 as PairKeyData;
    hash.bhp256 r11 into r12 as field;
    get pairs[r12] into r13;
    is.eq r7 r0 into r14;
    ternary r14 r13.reserve_a r13.reserve_b into r15;
    is.eq r7 r1 into r16;
    ternary r16 r13.reserve_a r13.reserve_b into r17;
    mul r15 r3 into r18;
    mul r18 1000u128 into r19;
    sub r17 r3 into r20;
    mul r20 997u128 into r21;
    div r19 r21 into r22;
    add r22 1u128 into r23;
    lte r23 r2 into r24;
    assert.eq r24 true ;
    gt r23 0u128 into r25;
    assert.eq r25 true ;
    cast r0 r5 into r26 as BalanceKeyData;
    hash.bhp256 r26 into r27 as field;
    sub r2 r23 into r28;
    get.or_use balances[r27] 0u128 into r29;
    add r29 r28 into r30;
    set r30 into balances[r27];
    add r15 r23 into r31;
    sub r17 r3 into r32;
    is.eq r7 r0 into r33;
    ternary r33 r31 r32 into r34;
    is.eq r9 r0 into r35;
    ternary r35 r31 r32 into r36;
    cast r34 r36 into r37 as Pair;
    set r37 into pairs[r12];
    cast r1 r4 into r38 as BalanceKeyData;
    hash.bhp256 r38 into r39 as field;
    get.or_use balances[r39] 0u128 into r40;
    add r40 r3 into r41;
    set r41 into balances[r39];

function swap_private_for_exact_private:
    input r0 as PrivateToken.record;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.private;
    input r5 as address.public;
    is.neq r0.token r1 into r6;
    assert.eq r6 true ;
    gt r3 0u128 into r7;
    assert.eq r7 true ;
    cast r4 r1 r3 into r8 as PrivateToken.record;
    sub r0.amount r2 into r9;
    cast r0.owner r0.token r9 into r10 as PrivateToken.record;
    async swap_private_for_exact_private r0.token r1 r2 r3 r5 into r11;
    output r8 as PrivateToken.record;
    output r10 as PrivateToken.record;
    output r11 as aleoswap06.aleo/swap_private_for_exact_private.future;

finalize swap_private_for_exact_private:
    input r0 as field.public;
    input r1 as field.public;
    input r2 as u128.public;
    input r3 as u128.public;
    input r4 as address.public;
    lt r0 r1 into r5;
    ternary r5 r0 r1 into r6;
    lt r0 r1 into r7;
    ternary r7 r1 r0 into r8;
    lt r6 r8 into r9;
    assert.eq r9 true ;
    cast r6 r8 into r10 as PairKeyData;
    hash.bhp256 r10 into r11 as field;
    get pairs[r11] into r12;
    is.eq r6 r0 into r13;
    ternary r13 r12.reserve_a r12.reserve_b into r14;
    is.eq r6 r1 into r15;
    ternary r15 r12.reserve_a r12.reserve_b into r16;
    mul r14 r3 into r17;
    mul r17 1000u128 into r18;
    sub r16 r3 into r19;
    mul r19 997u128 into r20;
    div r18 r20 into r21;
    add r21 1u128 into r22;
    lte r22 r2 into r23;
    assert.eq r23 true ;
    gt r22 0u128 into r24;
    assert.eq r24 true ;
    cast r0 r4 into r25 as BalanceKeyData;
    hash.bhp256 r25 into r26 as field;
    sub r2 r22 into r27;
    get.or_use balances[r26] 0u128 into r28;
    add r28 r27 into r29;
    set r29 into balances[r26];
    add r14 r22 into r30;
    sub r16 r3 into r31;
    is.eq r6 r0 into r32;
    ternary r32 r30 r31 into r33;
    is.eq r8 r0 into r34;
    ternary r34 r30 r31 into r35;
    cast r33 r35 into r36 as Pair;
    set r36 into pairs[r11];
